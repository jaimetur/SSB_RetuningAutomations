<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSB Retuning Automations - Administration Panel</title>
  <link rel="stylesheet" href="/static/styles.css" />
  <link rel="icon" type="image/png" href="/assets/logos/logo_02.png" />
</head>
<body>
  <!-- Admin management dashboard -->
  <main class="container">
    <header class="topbar">
      <div>
        <h1>SSB Retuning Automations - Administration Panel</h1>
        <div class="header-meta">v{{ tool_meta.version }} - {{ tool_meta.date }}</div>
      </div>
      <nav>
        <div class="user-meta">User: <b>{{ user.username }}</b> ({{ user.role }})</div>
        <div class="nav-links">
          <a href="/">Home</a>
          <a href="/logout">Sign out</a>
        </div>
      </nav>
    </header>


    <section class="card">
      <div class="runs-header">
        <h2>Processing Limits</h2>
        <div class="runs-actions">
          <button type="button" id="toggle_limits_panel" class="panel-toggle" aria-label="Collapse processing limits panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <div id="limits_panel_content">
      <form method="post" action="/admin/settings" class="inline admin-limits-form">
        <label>Max CPU % <input type="number" name="max_cpu_percent" min="10" max="100" value="{{ admin_settings.max_cpu_percent }}" /></label>
        <label>Max Memory % <input type="number" name="max_memory_percent" min="10" max="100" value="{{ admin_settings.max_memory_percent }}" /></label>
        <label>Max parallel tasks <input type="number" name="max_parallel_tasks" min="1" max="8" value="{{ admin_settings.max_parallel_tasks }}" /></label>
        <button type="submit" class="btn btn-primary">Save limits</button>
      </form>
      </div>
    </section>


    <section class="card">
      <div class="runs-header">
        <h2>Create user</h2>
        <div class="runs-actions">
          <button type="button" id="toggle_create_user_panel" class="panel-toggle" aria-label="Collapse create user panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <div id="create_user_panel_content">
      <form method="post" action="/admin/users/create" class="inline">
        <input type="text" name="username" placeholder="username" required />
        <input type="password" name="password" placeholder="temporary password" required />
        <select name="role">
          <option value="user">user</option>
          <option value="admin">admin</option>
        </select>
        <button type="submit">Create</button>
      </form>
      </div>
    </section>

    <section class="card">
      <div class="runs-header">
        <h2>Users <span id="connected_users_badge" class="connected-users-badge">Connected: {{ connected_users_count }}</span></h2>
        <div class="runs-actions">
          <select id="users_filter_combo" aria-label="Users filter">
            <option value="all" selected>Select All</option>
            <option value="connected">Connected Users</option>
            <option value="not_connected">No Connected Users</option>
            <option value="admin_role">Admin Role</option>
            <option value="user_role">User Role</option>
            <option value="active_users">Active Users</option>
            <option value="inactive_users">Innactive Users</option>
          </select>
          <button type="button" id="toggle_users_panel" class="panel-toggle" aria-label="Collapse users panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <div class="table-scroll latest-global-scroll" id="users_panel_table">
      <table>
        <thead><tr><th class="sortable" data-sort-id="user" data-sort-key="text" data-default-sort="asc">User</th><th class="sortable" data-sort-id="password" data-sort-key="text">Password</th><th class="sortable" data-sort-id="role" data-sort-key="text">Role</th><th class="sortable" data-sort-id="status" data-sort-key="text">Status</th><th class="sortable" data-sort-id="connected" data-sort-key="text">Connected</th><th class="sortable" data-sort-id="last_connection" data-sort-key="datetime">Last Connection</th><th class="sortable" data-sort-id="logged_time" data-sort-key="duration">Logged time</th><th class="sortable" data-sort-id="execution_time" data-sort-key="duration">Execution time</th><th class="sortable" data-sort-id="storage" data-sort-key="size">Storage</th><th class="sortable" data-sort-id="actions" data-sort-key="text">Actions</th></tr></thead>
        <tbody>
          {% for u in users %}
          <tr data-user-role="{{ u.role }}" data-user-active="{{ 1 if u.active else 0 }}" data-user-connected="{{ 1 if u.connected else 0 }}">
            <td>
                <input type="text" name="username" value="{{ u.username }}" form="update_user_{{ u.id }}" required class="user-input" {% if u.access_request_reason %}title="Access request reason: {{ u.access_request_reason }}"{% endif %} />
            </td>
            <td>
                <input type="password" name="new_password" placeholder="new password" form="update_user_{{ u.id }}" class="password-input" />
            </td>
            <td>
                <select name="role" form="update_user_{{ u.id }}">
                  <option value="user" {% if u.role == 'user' %}selected{% endif %}>user</option>
                  <option value="admin" {% if u.role == 'admin' %}selected{% endif %}>admin</option>
                </select>
            </td>
            <td>
                <select name="active" form="update_user_{{ u.id }}">
                  <option value="1" {% if u.active %}selected{% endif %}>active</option>
                  <option value="0" {% if not u.active %}selected{% endif %}>inactive</option>
                </select>
            </td>
            <td class="cell-middle">{{ "connected" if u.connected else "not connected" }}</td>
            <td class="cell-middle cell-nowrap">{{ u.last_connection }}</td>
            <td class="cell-middle">{{ u.total_login_hms }}</td>
            <td class="cell-middle">{{ u.total_execution_hms }}</td>
            <td class="storage-cell cell-middle">{{ u.storage_size }}</td>
            <td>
              <div class="action-row">
                <form method="post" action="/admin/users/{{ u.id }}/clear_storage" class="inline confirm-form" data-confirm="This will delete all Uploads and Exports for this user. Continue?">
                  <button type="submit" class="btn btn-success">Clear storage</button>
                </form>
                <form method="post" action="/admin/users/{{ u.id }}/update" class="inline" id="update_user_{{ u.id }}">
                  <button type="submit" class="btn btn-primary">Update user</button>
                </form>
                <form method="post" action="/admin/users/{{ u.id }}/delete" class="inline confirm-form" data-confirm="This will delete the user and all Uploads/Exports. Continue?">
                  <button type="submit" class="btn btn-danger">Delete user</button>
                </form>
              </div>
            </td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
      </div>
    </section>

    <section class="card">
      <div class="runs-header">
        <div>
          <h2>Inputs Repository</h2>
          <span class="runs-total" id="inputs_total_size">Total size: {{ inputs_total_size }} · Selected size: 0.00 MB</span>
        </div>
        <div class="runs-actions">
          <select id="select_user_inputs_combo"><option value="__all__" selected>All Users</option><option value="__last24h__">Last 24h</option></select>
          <input id="admin_inputs_name_filter_combo" class="combo-filter" list="admin_inputs_name_filter_presets" value="" placeholder="Wildcard Filter (*text*)" aria-label="Input name pattern filter" />
          <datalist id="admin_inputs_name_filter_presets"></datalist>
          <select id="inputs_bulk_select_action" aria-label="Bulk input selection">
            <option value="" selected>Select</option>
            <option value="all">Select All</option>
            <option value="none">Select None</option>
            <option value="older">Select Older</option>
          </select>
          <button type="button" id="admin_upload_inputs" class="btn btn-primary">Upload</button>
          <button type="button" id="rename_inputs" class="btn btn-secondary">Rename</button>
          <button type="button" id="delete_selected_inputs" class="btn btn-danger danger-anchor">Delete Selected</button>
          <button type="button" id="toggle_inputs_panel" class="panel-toggle" aria-label="Collapse inputs panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <input type="date" id="older_input_date_picker" class="hidden" />
      <input type="file" id="admin_inputs_upload_picker" class="hidden" accept=".zip" multiple />
      <div class="table-scroll history-scroll inputs-scroll" id="inputs_panel_table">
      <table>
        <thead><tr><th></th><th class="sortable" data-sort-key="text">Input</th><th class="sortable" data-sort-key="text">Uploaded by</th><th class="sortable" data-sort-key="datetime" data-default-sort="desc">Uploaded at</th><th class="sortable" data-sort-key="size">Size</th></tr></thead>
        <tbody>
          {% for item in input_items %}
          <tr>
            <td><input type="checkbox" class="input-checkbox" value="{{ item.id }}" data-uploaded-at="{{ item.uploaded_at }}" /></td>
            <td>{{ item.input_name }}</td><td>{{ item.uploaded_by }}</td><td>{{ item.uploaded_at }}</td><td>{{ item.size_mb }}</td>
          </tr>
          {% else %}
          <tr><td colspan="5">No inputs yet.</td></tr>
          {% endfor %}
        </tbody>
      </table>
      </div>
    </section>

    <section class="card">
      <div class="runs-header">
        <div class="runs-title-row">
          <div>
            <h2>Global Executions History</h2>
            <span class="runs-total" id="runs_total_size">Total size: {{ global_runs_size }} · Selected size: 0.00 MB</span>
          </div>
        </div>
        <div class="runs-actions">
          <select id="select_user_runs_combo"><option value="__all__" selected>All Users</option><option value="__last24h__">Last 24h</option></select>
          <input id="admin_runs_pattern_filter_combo" class="combo-filter" list="admin_runs_pattern_filter_presets" value="" placeholder="Wildcard Filter (*text*)" aria-label="Runs pattern filter" />
          <datalist id="admin_runs_pattern_filter_presets"></datalist>
          <select id="runs_bulk_select_action" aria-label="Bulk run selection">
            <option value="" selected>Select</option>
            <option value="all">Select All</option>
            <option value="none">Select None</option>
            <option value="running">Select Running</option>
            <option value="queued">Select Queued</option>
            <option value="error">Select Error</option>
            <option value="canceled">Select Cancelled</option>
            <option value="older">Select Older</option>
          </select>
          <button type="button" id="admin_rerun_selected_runs" class="btn btn-success">Re-Run Selected</button>
          <button type="button" id="admin_stop_selected_runs" class="btn btn-danger">Stop Selected</button>
          <button type="button" id="delete_selected_runs" class="btn btn-danger">Delete Selected</button>
          <button type="button" id="toggle_runs_panel" class="panel-toggle" aria-label="Collapse runs panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <input type="date" id="older_date_picker" class="hidden" />
      <div class="table-scroll history-scroll runs-scroll" id="runs_panel_table">
      <table>
        <thead><tr><th></th><th class="sortable" data-sort-key="number" data-default-sort="desc">ID</th><th class="sortable" data-sort-key="text">User</th><th class="sortable" data-sort-key="text">Module</th><th class="sortable" data-sort-key="text">Version</th><th class="sortable" data-sort-key="text">Input</th><th class="sortable" data-sort-key="text">Status</th><th class="sortable" data-sort-key="datetime">Start</th><th class="sortable" data-sort-key="datetime">End</th><th class="sortable" data-sort-key="duration">Duration</th><th class="sortable" data-sort-key="text">Output</th><th class="sortable" data-sort-key="text">Log</th><th class="sortable" data-sort-key="size">Size</th></tr></thead>
        <tbody>
          {% for r in recent_runs %}
          <tr class="{% if r.status_lower == 'error' %}run-error{% elif r.status_lower == 'success' %}run-success{% endif %}" data-status="{{ r.status_lower }}">
            <td><input type="checkbox" class="run-checkbox" value="{{ r.id }}" data-start="{{ r.started_at }}" data-status="{{ r.status_lower }}" /></td>
            <td>{{ r.id }}</td>
            <td>{{ r.username }}</td>
            <td>{{ r.module }}</td>
            <td>{{ r.tool_version or '—' }}</td>
            <td>{{ r.input_name or "—" }}</td><td>{{ r.status_display }}</td>
            <td>{{ r.started_at }}</td>
            <td>{{ r.finished_at }}</td>
            <td>{{ r.duration_hms }}</td>
            <td>
              {% if r.output_zip %}
                <a href="/admin/runs/{{ r.id }}/download">Download zip</a>
              {% else %}
                —
              {% endif %}
            </td>
            <td>
              {% if r.output_log_file %}
                <a href="/admin/runs/{{ r.id }}/log">Download log</a>
              {% else %}
                —
              {% endif %}
            </td>
            <td>{{ r.size_mb }}</td>
          </tr>
          {% else %}
            <tr><td colspan="13">No runs yet.</td></tr>
          {% endfor %}
        </tbody>
      </table>
      </div>
    </section>


    <section class="card">
      <div class="runs-header">
        <h2>Database Backup</h2>
        <div class="runs-actions">
          <button type="button" id="toggle_db_backup_panel" class="panel-toggle" aria-label="Collapse database backup panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <div id="db_backup_panel_content">
      <div class="db-backup-actions">
        <form method="get" action="/admin/database/export" class="inline">
          <button type="submit" class="btn btn-primary">Export DB Backup</button>
        </form>
        <form method="post" action="/admin/database/import" enctype="multipart/form-data" class="inline db-backup-import-form" id="db_backup_import_form" novalidate>
          <button type="submit" class="btn btn-danger">Import DB Backup</button>
          <div class="db-backup-file-picker">
            <input type="file" name="backup_file" id="db_backup_file_input" accept=".db,.sqlite,.sqlite3" />
            <button type="button" class="btn btn-neutral" id="db_backup_pick_file">Select file</button>
            <span id="db_backup_file_name" class="db-backup-file-name">No file selected</span>
          </div>
        </form>
      </div>
      <p class="db-backup-warning"><small>Import replaces the current database file after basic validation.</small></p>
      <form method="post" action="/admin/settings" class="admin-db-backup-auto-form" style="margin-top: 1rem;">
        <input type="hidden" name="max_cpu_percent" value="{{ admin_settings.max_cpu_percent }}" />
        <input type="hidden" name="max_memory_percent" value="{{ admin_settings.max_memory_percent }}" />
        <input type="hidden" name="max_parallel_tasks" value="{{ admin_settings.max_parallel_tasks }}" />

        <div class="inline" style="align-items: center; gap: .6rem; flex-wrap: wrap;">
          <label for="db_backup_auto_mode">Automatic DB Backup</label>
          <select id="db_backup_auto_mode" name="db_backup_auto_mode">
            <option value="disabled" {% if admin_settings.db_backup_auto_mode == 'disabled' %}selected{% endif %}>Disabled</option>
            <option value="daily" {% if admin_settings.db_backup_auto_mode == 'daily' %}selected{% endif %}>Daily</option>
            <option value="weekly" {% if admin_settings.db_backup_auto_mode == 'weekly' %}selected{% endif %}>Weekly (every Mondays)</option>
            <option value="monthly" {% if admin_settings.db_backup_auto_mode == 'monthly' %}selected{% endif %}>Monthly (every 1st)</option>
          </select>
        </div>

        <div class="inline" style="align-items: center; gap: .6rem; flex-wrap: wrap; margin-top: .5rem;">
          <label for="db_backup_auto_path">Backup path</label>
          <input id="db_backup_auto_path" type="text" name="db_backup_auto_path" value="{{ admin_settings.db_backup_auto_path }}" placeholder="/path/to/backups" style="min-width: 26rem;" />
          <button type="button" class="btn btn-neutral" id="db_backup_pick_folder">Select Folder</button>
        </div>

        <div class="inline" style="align-items: center; gap: .6rem; flex-wrap: wrap; margin-top: .5rem;">
          <label for="db_backup_auto_hour">Backup hour (0-23)</label>
          <input id="db_backup_auto_hour" type="number" name="db_backup_auto_hour" min="0" max="23" value="{{ admin_settings.db_backup_auto_hour }}" style="width: 4.6rem;" />
        </div>

        <div class="inline" style="align-items: center; gap: .6rem; flex-wrap: wrap; margin-top: .5rem;">
          <label for="db_backup_max_to_store">Max. Backups to store</label>
          <input id="db_backup_max_to_store" type="number" name="db_backup_max_to_store" min="1" max="3650" value="{{ admin_settings.db_backup_max_to_store }}" style="width: 6rem;" />
        </div>

        <button type="submit" class="btn btn-primary" style="margin-top: .5rem;">Save backup automation</button>
      </form>
      </div>
    </section>

    <section class="card log-card">
      <div class="log-header">
        <h2>Database Editor</h2>
        <div class="log-actions">
          <label class="inline">
            <select id="admin_db_table_selector">
              <option value="" selected>Select Table</option>
              {% for table_name in editable_tables %}
                <option value="{{ table_name }}">{{ table_name }}</option>
              {% endfor %}
            </select>
          </label>
          <button type="button" id="admin_db_reload_table" class="btn btn-primary">Refresh table</button>
          <button type="button" id="admin_db_cancel_changes" class="btn btn-primary">Cancel</button>
          <button type="button" id="admin_db_update_changes" class="btn btn-danger">Update</button>
          <button type="button" id="toggle_db_editor_panel" class="panel-toggle" aria-label="Collapse database editor panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <div id="db_editor_panel_content">
      <div class="table-scroll history-scroll" id="admin_db_editor_wrapper">
        <table id="admin_db_editor_table">
          <thead><tr><th>Select Table</th></tr></thead>
          <tbody><tr><td>Select a table to edit.</td></tr></tbody>
        </table>
      </div>
      </div>
    </section>
    <section class="card log-card">
      <div class="log-header">
        <h2>Executions Logs</h2>
        <div class="log-actions">
          <select id="admin_log_run_selector">
            {% for r in recent_runs %}
              <option value="{{ r.id }}" {% if loop.first %}selected{% endif %}>#{{ r.id }} - {{ r.module }} - {{ r.started_at or '—' }}</option>
            {% endfor %}
          </select>
          <label class="checkbox">
            <input type="checkbox" id="admin_execution_log_auto" disabled />
            Auto refresh
          </label>
          <button type="button" id="admin_refresh_log">Refresh</button>
          <button type="button" id="admin_copy_log">Copy all</button>
          <button type="button" id="admin_copy_selection">Copy selection</button>
          <button type="button" id="toggle_admin_execution_log_panel" class="panel-toggle" aria-label="Collapse execution log panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <pre id="admin_log_output" class="log-output">No logs yet.</pre>
    </section>

    <section class="card log-card">
      <div class="log-header">
        <h2>System Logs</h2>
        <div class="log-actions">
          <select id="admin_system_log_source">
            <option value="app" selected>Application</option>
            <option value="api">API</option>
            <option value="web-access">Web Access</option>
          </select>
          <label class="checkbox">
            <input type="checkbox" id="admin_system_log_auto" />
            Auto refresh
          </label>
          <button type="button" id="admin_refresh_system_log">Refresh</button>
          <button type="button" id="admin_copy_system_log">Copy all</button>
          <button type="button" id="admin_copy_system_selection">Copy selection</button>
          <button type="button" id="admin_delete_system_log" class="btn btn-danger">Delete</button>
          <button type="button" id="toggle_admin_system_log_panel" class="panel-toggle" aria-label="Collapse system log panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <pre id="admin_system_log_output" class="log-output">No logs yet.</pre>
    </section>


  </main>
  <script>

    function showModal({ title = "Notice", message = "", confirmText = "Accept", cancelText = "" }) {
      return new Promise((resolve) => {
        const backdrop = document.createElement("div");
        backdrop.className = "modal-backdrop";
        const box = document.createElement("div");
        box.className = "modal-box";
        const titleEl = document.createElement("h3");
        titleEl.className = "modal-title";
        titleEl.textContent = title;
        const messageEl = document.createElement("p");
        messageEl.className = "modal-message";
        messageEl.textContent = message;
        const actions = document.createElement("div");
        actions.className = "modal-actions";

        if (cancelText) {
          const cancelBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.className = "btn btn-danger";
          cancelBtn.textContent = cancelText;
          cancelBtn.addEventListener("click", () => {
            backdrop.remove();
            resolve(false);
          });
          actions.appendChild(cancelBtn);
        }

        const okBtn = document.createElement("button");
        okBtn.type = "button";
        okBtn.className = "btn btn-primary";
        okBtn.textContent = confirmText;
        okBtn.addEventListener("click", () => {
          backdrop.remove();
          resolve(true);
        });
        actions.appendChild(okBtn);

        box.appendChild(titleEl);
        box.appendChild(messageEl);
        box.appendChild(actions);
        backdrop.appendChild(box);
        document.body.appendChild(backdrop);
      });
    }

    document.querySelectorAll(".confirm-form").forEach((form) => {
      form.addEventListener("submit", async (event) => {
        if (form.dataset.confirmed === "1") {
          delete form.dataset.confirmed;
          return;
        }

        event.preventDefault();
        const message = form.dataset.confirm || "Are you sure?";
        const ok = await showModal({ title: "Please confirm", message, confirmText: "Accept", cancelText: "Cancel" });
        if (!ok) {
          return;
        }

        form.dataset.confirmed = "1";
        form.requestSubmit();
      });
    });

    const toggleLimitsPanelButton = document.getElementById("toggle_limits_panel");
    const limitsPanelContent = document.getElementById("limits_panel_content");
    const toggleCreateUserPanelButton = document.getElementById("toggle_create_user_panel");
    const createUserPanelContent = document.getElementById("create_user_panel_content");
    const toggleDbBackupPanelButton = document.getElementById("toggle_db_backup_panel");
    const dbBackupPanelContent = document.getElementById("db_backup_panel_content");
    const toggleDbEditorPanelButton = document.getElementById("toggle_db_editor_panel");
    const dbEditorPanelContent = document.getElementById("db_editor_panel_content");
    const runsBulkSelectAction = document.getElementById("runs_bulk_select_action");
    const selectUserRunsCombo = document.getElementById("select_user_runs_combo");
    const adminRerunSelectedRunsButton = document.getElementById("admin_rerun_selected_runs");
    const adminStopSelectedRunsButton = document.getElementById("admin_stop_selected_runs");
    const deleteSelectedRunsButton = document.getElementById("delete_selected_runs");
    const toggleRunsPanelButton = document.getElementById("toggle_runs_panel");
    const runsTable = document.getElementById("runs_panel_table");
    const inputsBulkSelectAction = document.getElementById("inputs_bulk_select_action");
    const selectUserInputsCombo = document.getElementById("select_user_inputs_combo");
    const adminInputsNameFilterCombo = document.getElementById("admin_inputs_name_filter_combo");
    const adminRunsPatternFilterCombo = document.getElementById("admin_runs_pattern_filter_combo");
    const adminUploadInputsButton = document.getElementById("admin_upload_inputs");
    const adminInputsUploadPicker = document.getElementById("admin_inputs_upload_picker");
    const deleteSelectedInputsButton = document.getElementById("delete_selected_inputs");
    const renameInputsButton = document.getElementById("rename_inputs");
    const olderInputDatePicker = document.getElementById("older_input_date_picker");
    const toggleInputsPanelButton = document.getElementById("toggle_inputs_panel");
    const inputsPanelTable = document.getElementById("inputs_panel_table");
    const toggleUsersPanelButton = document.getElementById("toggle_users_panel");
    const usersPanelTable = document.getElementById("users_panel_table");
    const usersFilterCombo = document.getElementById("users_filter_combo");
    const connectedUsersBadge = document.getElementById("connected_users_badge");
    const adminLogRunSelector = document.getElementById("admin_log_run_selector");
    const adminRefreshLogButton = document.getElementById("admin_refresh_log");
    const adminClearLogButton = document.getElementById("admin_clear_log");
    const adminCopyLogButton = document.getElementById("admin_copy_log");
    const adminCopySelectionButton = document.getElementById("admin_copy_selection");
    const toggleAdminExecutionLogPanelButton = document.getElementById("toggle_admin_execution_log_panel");
    const adminLogOutput = document.getElementById("admin_log_output");
    const adminExecutionLogAuto = document.getElementById("admin_execution_log_auto");
    const adminSystemLogSource = document.getElementById("admin_system_log_source");
    const adminRefreshSystemLogButton = document.getElementById("admin_refresh_system_log");
    const adminSystemLogAuto = document.getElementById("admin_system_log_auto");
    const adminClearSystemLogButton = document.getElementById("admin_clear_system_log");
    const adminCopySystemLogButton = document.getElementById("admin_copy_system_log");
    const adminCopySystemSelectionButton = document.getElementById("admin_copy_system_selection");
    const adminDeleteSystemLogButton = document.getElementById("admin_delete_system_log");
    const toggleAdminSystemLogPanelButton = document.getElementById("toggle_admin_system_log_panel");
    const adminSystemLogOutput = document.getElementById("admin_system_log_output");
    const adminDbTableSelector = document.getElementById("admin_db_table_selector");
    const adminDbReloadTableButton = document.getElementById("admin_db_reload_table");
    const adminDbCancelChangesButton = document.getElementById("admin_db_cancel_changes");
    const adminDbUpdateChangesButton = document.getElementById("admin_db_update_changes");
    const adminDbEditorTable = document.getElementById("admin_db_editor_table");
    const dbBackupImportForm = document.getElementById("db_backup_import_form");
    const dbBackupFileInput = document.getElementById("db_backup_file_input");
    const dbBackupPickFileButton = document.getElementById("db_backup_pick_file");
    const dbBackupFileName = document.getElementById("db_backup_file_name");
    const dbBackupPickFolderButton = document.getElementById("db_backup_pick_folder");
    const dbBackupAutoPathInput = document.getElementById("db_backup_auto_path");
    const inputsTotalSizeLabel = document.getElementById("inputs_total_size");
    const runsTotalSizeLabel = document.getElementById("runs_total_size");
    const ADMIN_EXECUTION_AUTO_CHECKED_KEY = "admin_execution_log_auto_checked";
    const ADMIN_SYSTEM_LOG_AUTO_CHECKED_KEY = "admin_system_log_auto_checked";
    let adminPersistedExecutionAutoChecked = false;
    let adminPersistedSystemLogAutoChecked = false;
    const persistedPanelStates = {{ (user_settings.get("ui_panels", {}) if user_settings else {}) | tojson }};
    const persistedAdminSystemLogSource = {{ (user_settings.get("admin_system_log_source") if user_settings else "app") | tojson }};
    const persistedAdminUsersFilter = {{ (user_settings.get("admin_users_filter") if user_settings else "all") | tojson }};
    const persistedAdminInputsFilter = {{ (user_settings.get("admin_inputs_filter") if user_settings else "__all__") | tojson }};
    const persistedAdminRunsFilter = {{ (user_settings.get("admin_runs_filter") if user_settings else "__all__") | tojson }};
    const persistedAdminUsersSort = {{ (user_settings.get("admin_users_sort") if user_settings else {}) | tojson }};
    let persistedInputsWildcardHistory = {{ (user_settings.get("wildcard_history_inputs", []) if user_settings else []) | tojson }};
    let persistedExecutionsWildcardHistory = {{ (user_settings.get("wildcard_history_executions", []) if user_settings else []) | tojson }};
    let panelStateSaveTimeout = null;
    try {
      adminPersistedExecutionAutoChecked = window.sessionStorage?.getItem(ADMIN_EXECUTION_AUTO_CHECKED_KEY) === "1";
      adminPersistedSystemLogAutoChecked = window.sessionStorage?.getItem(ADMIN_SYSTEM_LOG_AUTO_CHECKED_KEY) === "1";
    } catch (_error) {
      adminPersistedExecutionAutoChecked = false;
      adminPersistedSystemLogAutoChecked = false;
    }

    function savePanelStatesOnly() {
      if (panelStateSaveTimeout) clearTimeout(panelStateSaveTimeout);
      panelStateSaveTimeout = setTimeout(() => {
        fetch("/settings/update", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ ui_panels: { ...(persistedPanelStates || {}) } })
        }).catch(() => {});
      }, 200);
    }

    function persistAdminSystemLogSource(source) {
      fetch("/settings/update", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ admin_system_log_source: source || "app" })
      }).catch(() => {});
    }

    function persistAdminUsersFilter(filterValue) {
      fetch("/settings/update", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ admin_users_filter: filterValue || "all" })
      }).catch(() => {});
    }

    function normalizeWildcardPattern(rawValue) {
      const value = String(rawValue || "").trim();
      const lowered = value.toLowerCase();
      if (!value || lowered === "pattern filter" || lowered === "wildcard filter (*text*)") return "";
      return value;
    }

    function sanitizeWildcardHistory(items) {
      if (!Array.isArray(items)) return [];
      const result = [];
      for (const rawItem of items) {
        const normalized = normalizeWildcardPattern(rawItem);
        if (!normalized) continue;
        if (!result.includes(normalized)) result.push(normalized);
        if (result.length >= 10) break;
      }
      return result;
    }

    function renderWildcardHistory(datalistElement, history) {
      if (!datalistElement) return;
      datalistElement.innerHTML = sanitizeWildcardHistory(history)
        .map((value) => `<option value="${value.replace(/[&<>"']/g, (char) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[char]))}"></option>`)
        .join("");
    }

    function persistWildcardHistory(settingsKey, history) {
      fetch("/settings/update", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ [settingsKey]: sanitizeWildcardHistory(history) })
      }).catch(() => {});
    }

    function rememberWildcardPattern(rawValue, settingsKey, currentHistory, datalistElement) {
      const normalized = normalizeWildcardPattern(rawValue);
      if (!normalized) return currentHistory;
      const nextHistory = [normalized, ...sanitizeWildcardHistory(currentHistory).filter((item) => item !== normalized)].slice(0, 10);
      renderWildcardHistory(datalistElement, nextHistory);
      persistWildcardHistory(settingsKey, nextHistory);
      return nextHistory;
    }

    function persistAdminExecutionAutoCheckedState(isChecked) {
      adminPersistedExecutionAutoChecked = Boolean(isChecked);
      try {
        window.sessionStorage?.setItem(ADMIN_EXECUTION_AUTO_CHECKED_KEY, adminPersistedExecutionAutoChecked ? "1" : "0");
      } catch (_error) {
        // ignore storage errors
      }
    }

    function setAdminExecutionAutoChecked(isChecked) {
      if (!adminExecutionLogAuto) return;
      adminExecutionLogAuto.checked = Boolean(isChecked);
      persistAdminExecutionAutoCheckedState(adminExecutionLogAuto.checked);
    }

    function persistAdminSystemLogAutoCheckedState(isChecked) {
      adminPersistedSystemLogAutoChecked = Boolean(isChecked);
      try {
        window.sessionStorage?.setItem(ADMIN_SYSTEM_LOG_AUTO_CHECKED_KEY, adminPersistedSystemLogAutoChecked ? "1" : "0");
      } catch (_error) {
        // ignore storage errors
      }
    }

    if (adminExecutionLogAuto) adminExecutionLogAuto.checked = adminPersistedExecutionAutoChecked;
    if (adminSystemLogAuto) adminSystemLogAuto.checked = adminPersistedSystemLogAutoChecked;

    dbBackupPickFileButton?.addEventListener("click", () => {
      dbBackupFileInput?.click();
    });

    dbBackupFileInput?.addEventListener("change", () => {
      const selectedName = dbBackupFileInput.files?.[0]?.name || "No file selected";
      if (dbBackupFileName) dbBackupFileName.textContent = selectedName;
    });

    dbBackupPickFolderButton?.addEventListener("click", async () => {
      if (!dbBackupAutoPathInput) return;
      if (!("showDirectoryPicker" in window)) {
        alert("Folder picker is not supported in this browser. Please type the path manually.");
        return;
      }
      try {
        const handle = await window.showDirectoryPicker();
        if (handle?.name) {
          const currentValue = String(dbBackupAutoPathInput.value || "").trim();
          const guessedPath = currentValue
            ? `${currentValue.replace(/[\/]+$/, "")}/${handle.name}`
            : handle.name;
          dbBackupAutoPathInput.value = guessedPath;
        }
      } catch (_error) {
        // User cancelled folder selection.
      }
    });

    dbBackupImportForm?.addEventListener("submit", async (event) => {
      if (dbBackupFileInput?.files?.length) {
        return;
      }
      event.preventDefault();
      await showModal({ title: "Missing file", message: "Please select a file.", confirmText: "Accept" });
    });


    function parseSortableValue(rawValue, sortType) {
      const value = (rawValue || "").trim();
      if (sortType === "number") {
        const n = Number.parseFloat(value.replace(/[^0-9.-]/g, ""));
        return Number.isNaN(n) ? -1 : n;
      }
      if (sortType === "size") {
        const n = Number.parseFloat(value.replace(/[^0-9.]/g, ""));
        return Number.isNaN(n) ? -1 : n;
      }
      if (sortType === "duration") {
        const parts = value.split(":").map((item) => Number.parseInt(item, 10));
        if (parts.length === 3 && parts.every((item) => !Number.isNaN(item))) return (parts[0] * 3600) + (parts[1] * 60) + parts[2];
        return -1;
      }
      if (sortType === "datetime") {
        const normalized = value
          .replace(/^(\d{4})-(\d{2})-(\d{2})-(\d{2}:\d{2}:\d{2})$/, "$1-$2-$3T$4")
          .replace(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}:\d{2})$/, "$1-$2-$3T$4:00");
        const ts = Date.parse(normalized);
        return Number.isNaN(ts) ? -1 : ts;
      }
      return value.toLowerCase();
    }

    function persistAdminUsersSort(sortId, direction) {
      fetch("/settings/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ admin_users_sort: { sort_id: sortId || "", direction: direction || "asc" } })
      }).catch(() => {});
    }

    function getCellSortableText(cell) {
      if (!cell) return "";
      const input = cell.querySelector("input");
      if (input) return String(input.value || "").trim();
      const select = cell.querySelector("select");
      if (select) {
        const selectedOption = select.options?.[select.selectedIndex];
        return String(selectedOption?.textContent || select.value || "").trim();
      }
      return String(cell.textContent || "").trim();
    }

    function sortTableByHeader(table, header, forcedDirection = null, onSortChange = null) {
      const tbody = table?.querySelector("tbody");
      if (!tbody || !header) return;
      const rows = Array.from(tbody.querySelectorAll("tr"));
      if (rows.length <= 1) return;

      const headers = Array.from(table.querySelectorAll("thead th.sortable"));
      const columnIndex = Array.from(header.parentElement.children).indexOf(header);
      headers.forEach((other) => {
        if (!other.dataset.label) other.dataset.label = other.textContent.replace(/\s*[▲▼]$/, "").trim();
      });

      headers.forEach((other) => {
        if (other !== header) {
          other.dataset.sortDirection = "none";
          other.textContent = other.dataset.label || other.textContent.replace(/\s*[▲▼]$/, "").trim();
        }
      });

      const currentDirection = forcedDirection || (header.dataset.sortDirection === "asc" ? "desc" : "asc");
      header.dataset.sortDirection = currentDirection;
      const sortType = header.dataset.sortKey || "text";
      const baseLabel = header.dataset.label || header.textContent.replace(/\s*[▲▼]$/, "").trim();
      header.textContent = `${baseLabel} ${currentDirection === "asc" ? "▲" : "▼"}`;

      rows.sort((rowA, rowB) => {
        const aCell = rowA.cells[columnIndex];
        const bCell = rowB.cells[columnIndex];
        const aText = getCellSortableText(aCell);
        const bText = getCellSortableText(bCell);
        const aValue = parseSortableValue(aText, sortType);
        const bValue = parseSortableValue(bText, sortType);
        if (aValue < bValue) return currentDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return currentDirection === "asc" ? 1 : -1;
        return 0;
      });

      rows.forEach((row) => tbody.appendChild(row));

      if (typeof onSortChange === "function") {
        onSortChange(header, currentDirection);
      }
    }

    function applyCurrentOrDefaultSort(tableSelector, onSortChange = null) {
      const table = document.querySelector(tableSelector);
      if (!table) return;
      const headers = Array.from(table.querySelectorAll("thead th.sortable"));
      const activeHeader = headers.find((header) => ["asc", "desc"].includes(header.dataset.sortDirection));
      if (activeHeader) {
        sortTableByHeader(table, activeHeader, activeHeader.dataset.sortDirection, onSortChange);
        return;
      }
      const defaultHeader = headers.find((header) => header.dataset.defaultSort);
      if (defaultHeader) sortTableByHeader(table, defaultHeader, defaultHeader.dataset.defaultSort, onSortChange);
    }

    function initSortableTable(tableSelector, options = {}) {
      const table = document.querySelector(tableSelector);
      if (!table) return;
      const headers = Array.from(table.querySelectorAll("thead th.sortable"));
      const persistedSortId = options.persistedSort?.sort_id;
      const persistedDirection = options.persistedSort?.direction;
      headers.forEach((header) => {
        header.dataset.sortDirection = "none";
        header.dataset.label = header.textContent.replace(/\s*[▲▼]$/, "").trim();
        header.title = "Sort";
        if (persistedSortId && String(header.dataset.sortId || "") === String(persistedSortId)) {
          header.dataset.sortDirection = ["asc", "desc"].includes(persistedDirection) ? persistedDirection : "none";
        }
        header.addEventListener("click", () => sortTableByHeader(table, header, null, options.onSortChange));
      });
      applyCurrentOrDefaultSort(tableSelector, options.onSortChange);
    }

    function parseTableDateTime(rawValue) {
      const value = String(rawValue || "").trim();
      if (!value || value === "—") return null;
      const normalized = value
        .replace(/^(\d{4})-(\d{2})-(\d{2})-(\d{2}:\d{2}:\d{2})$/, "$1-$2-$3T$4")
        .replace(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}:\d{2})$/, "$1-$2-$3T$4:00");
      const timestamp = Date.parse(normalized);
      if (Number.isNaN(timestamp)) return null;
      return new Date(timestamp);
    }

    function isWithinLast24Hours(rawValue) {
      const parsed = parseTableDateTime(rawValue);
      if (!parsed) return false;
      return (Date.now() - parsed.getTime()) <= 24 * 60 * 60 * 1000;
    }

    function populateScopeCombo(combo, tableSelector, columnIndex) {
      if (!combo) return;
      const previous = combo.value;
      const users = Array.from(document.querySelectorAll(`${tableSelector} tbody tr`))
        .map((row) => row.cells?.[columnIndex]?.textContent?.trim() || "")
        .filter((value) => value && value !== "—");
      const uniqueUsers = Array.from(new Set(users)).sort((a, b) => a.localeCompare(b));
      combo.innerHTML = '<option value="__all__">All Users</option><option value="__last24h__">Last 24h</option>' + uniqueUsers.map((user) => `<option value="${user}">${user}</option>`).join("");
      combo.value = uniqueUsers.includes(previous) || previous === "__all__" || previous === "__last24h__" ? previous : "__all__";
    }


    function wildcardPatternToRegex(pattern) {
      const escaped = String(pattern || "")
        .split("*")
        .map((part) => part.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"))
        .join(".*");
      return new RegExp(`^${escaped}$`, "i");
    }

    function matchesInputsPattern(candidates, rawPattern) {
      const value = String(rawPattern || "").trim();
      if (!value || value.toLowerCase() === "pattern filter" || value.toLowerCase() === "wildcard filter (*text*)") return true;
      const values = Array.isArray(candidates) ? candidates.map((candidate) => String(candidate || "")) : [];
      if (value.includes("*")) {
        try {
          const regex = wildcardPatternToRegex(value);
          return values.some((candidate) => regex.test(candidate));
        } catch (_error) {
          return true;
        }
      }
      const lowered = value.toLowerCase();
      return values.some((candidate) => candidate.toLowerCase().includes(lowered));
    }

    function matchesAdminRunsPattern(row, rawPattern) {
      const value = String(rawPattern || "").trim();
      if (!value || value.toLowerCase() === "pattern filter" || value.toLowerCase() === "wildcard filter (*text*)") return true;
      const candidates = [
        row?.cells?.[2]?.textContent?.trim() || "", // User
        row?.cells?.[3]?.textContent?.trim() || "", // Module
        row?.cells?.[4]?.textContent?.trim() || "", // Version
        row?.cells?.[5]?.textContent?.trim() || "", // Input
        row?.cells?.[6]?.textContent?.trim() || "", // Status
        row?.cells?.[7]?.textContent?.trim() || "", // Start
      ];
      if (value.includes("*")) {
        try {
          const regex = wildcardPatternToRegex(value);
          return candidates.some((candidate) => regex.test(candidate));
        } catch (_error) {
          return true;
        }
      }
      const lowered = value.toLowerCase();
      return candidates.some((candidate) => candidate.toLowerCase().includes(lowered));
    }

    function applyAdminRunsFilters() {
      const mode = selectUserRunsCombo?.value || "__all__";
      const pattern = adminRunsPatternFilterCombo?.value || "";
      document.querySelectorAll('#runs_panel_table tbody tr').forEach((row) => {
        const rowUser = row?.cells?.[2]?.textContent?.trim() || "";
        const matchesUser = mode === "__all__" || rowUser === mode || (mode === "__last24h__" && isWithinLast24Hours(row?.cells?.[7]?.textContent || ""));
        const matchesPattern = matchesAdminRunsPattern(row, pattern);
        row.classList.toggle('hidden', !(matchesUser && matchesPattern));
      });
    }

    function applyAdminInputsFilters() {
      const mode = selectUserInputsCombo?.value || "__all__";
      const pattern = adminInputsNameFilterCombo?.value || "";
      document.querySelectorAll('#inputs_panel_table tbody tr').forEach((row) => {
        const rowUser = row?.cells?.[2]?.textContent?.trim() || "";
        const inputName = row?.cells?.[1]?.textContent?.trim() || "";
        const uploadedBy = row?.cells?.[2]?.textContent?.trim() || "";
        const uploadedAt = row?.cells?.[3]?.textContent?.trim() || "";
        const matchesUser = mode === "__all__" || rowUser === mode || (mode === "__last24h__" && isWithinLast24Hours(uploadedAt));
        const matchesPattern = matchesInputsPattern([inputName, uploadedBy, uploadedAt], pattern);
        row.classList.toggle('hidden', !(matchesUser && matchesPattern));
      });
    }

    function applyUsersPanelFilter() {
      const mode = usersFilterCombo?.value || "all";
      document.querySelectorAll('#users_panel_table tbody tr').forEach((row) => {
        const role = (row.dataset.userRole || "").toLowerCase();
        const active = String(row.dataset.userActive || "0") === "1";
        const connected = String(row.dataset.userConnected || "0") === "1";
        let show = true;
        if (mode === "connected") show = connected;
        else if (mode === "not_connected") show = !connected;
        else if (mode === "admin_role") show = role === "admin";
        else if (mode === "user_role") show = role === "user";
        else if (mode === "active_users") show = active;
        else if (mode === "inactive_users") show = !active;
        row.classList.toggle('hidden', !show);
      });
    }

    function countConnectedUsersInTable() {
      return Array.from(document.querySelectorAll('#users_panel_table tbody tr'))
        .filter((row) => String(row.dataset.userConnected || "0") === "1")
        .length;
    }

    function updateConnectedUsersBadge(count) {
      if (!connectedUsersBadge) return;
      connectedUsersBadge.textContent = `Connected: ${Number(count) || 0}`;
    }

    async function refreshConnectedUsersBadge() {
      try {
        const response = await fetch(`/admin/users/connected_status?_=${Date.now()}`);
        if (!response.ok) throw new Error("bad status");
        const data = await response.json();
        if (!data?.ok) throw new Error("invalid payload");
        updateConnectedUsersBadge(data.connected_users);
      } catch (_error) {
        updateConnectedUsersBadge(countConnectedUsersInTable());
      }
    }

    function toggleVisibleCheckboxes(tableSelector, checkboxSelector, checked) {
      document.querySelectorAll(`${tableSelector} tbody tr`).forEach((row) => {
        if (row.classList.contains("hidden")) return;
        const box = row.querySelector(checkboxSelector);
        if (box) box.checked = checked;
      });
      updateSelectionSizeLabels();
    }


    function parseSizeMb(value) {
      if (!value) {
        return 0;
      }
      const cleaned = String(value).replace(',', '.');
      const match = cleaned.match(/([\d.]+)/);
      return match ? Number(match[1]) || 0 : 0;
    }

    function formatSizeMb(valueMb) {
      return `${valueMb.toFixed(2)} MB`;
    }

    function updateSelectionSizeLabels() {
      if (inputsTotalSizeLabel) {
        let visibleTotalMb = 0;
        let selectedMb = 0;
        document.querySelectorAll('#inputs_panel_table tbody tr').forEach((row) => {
          if (row.classList.contains('hidden')) return;
          const rowSize = parseSizeMb(row?.cells?.[4]?.textContent || '0 MB');
          visibleTotalMb += rowSize;
          const box = row.querySelector('.input-checkbox');
          if (box?.checked) selectedMb += rowSize;
        });
        inputsTotalSizeLabel.textContent = `Total size: ${formatSizeMb(visibleTotalMb)} · Selected size: ${formatSizeMb(selectedMb)}`;
      }
      if (runsTotalSizeLabel) {
        let visibleTotalMb = 0;
        let selectedMb = 0;
        document.querySelectorAll('#runs_panel_table tbody tr').forEach((row) => {
          if (row.classList.contains('hidden')) return;
          const rowSize = parseSizeMb(row?.cells?.[12]?.textContent || '0 MB');
          visibleTotalMb += rowSize;
          const box = row.querySelector('.run-checkbox');
          if (box?.checked) selectedMb += rowSize;
        });
        runsTotalSizeLabel.textContent = `Total size: ${formatSizeMb(visibleTotalMb)} · Selected size: ${formatSizeMb(selectedMb)}`;
      }
    }

    function bindPanelToggle(button, panel, stateKey) {
      if (!button || !panel) return;
      const collapsed = Boolean(persistedPanelStates?.[stateKey]);
      panel.classList.toggle("hidden", collapsed);
      button.textContent = collapsed ? "▸" : "▾";
      button.addEventListener("click", () => {
        panel.classList.toggle("hidden");
        const nowCollapsed = panel.classList.contains("hidden");
        button.textContent = nowCollapsed ? "▸" : "▾";
        persistedPanelStates[stateKey] = nowCollapsed;
        savePanelStatesOnly();
      });
    }

    bindPanelToggle(toggleLimitsPanelButton, limitsPanelContent, "admin_limits");
    bindPanelToggle(toggleCreateUserPanelButton, createUserPanelContent, "admin_create_user");
    bindPanelToggle(toggleDbBackupPanelButton, dbBackupPanelContent, "admin_db_backup");
    bindPanelToggle(toggleDbEditorPanelButton, dbEditorPanelContent, "admin_db_editor");
    bindPanelToggle(toggleRunsPanelButton, runsTable, "admin_runs");
    bindPanelToggle(toggleInputsPanelButton, inputsPanelTable, "admin_inputs");
    bindPanelToggle(toggleUsersPanelButton, usersPanelTable, "admin_users");
    bindPanelToggle(toggleAdminExecutionLogPanelButton, adminLogOutput, "admin_execution_log");
    bindPanelToggle(toggleAdminSystemLogPanelButton, adminSystemLogOutput, "admin_system_log");

    function getSelectedRunIds() {
      return Array.from(document.querySelectorAll(".run-checkbox:checked")).map((box) => Number(box.value));
    }

    function selectErrorRuns() {
      const table = document.querySelector("#runs_panel_table table");
      const headerCells = table ? table.querySelectorAll("thead th") : [];
      let statusIndex = -1;
      headerCells.forEach((cell, index) => {
        if (cell.textContent.trim().toLowerCase() === "status") {
          statusIndex = index;
        }
      });
      document.querySelectorAll(".run-checkbox").forEach((box) => {
        const row = box.closest("tr");
        const statusColumn = row && statusIndex >= 0 ? row.cells[statusIndex] : null;
        const statusText = statusColumn ? statusColumn.textContent.trim().toLowerCase() : "";
        const statusAttr = (row?.dataset.status || box.dataset.status || "").trim().toLowerCase();
        if (statusText === "error" || statusAttr === "error" || row?.classList.contains("run-error")) {
          box.checked = true;
        }
      });
    }

    function selectRunsByStatuses(statuses) {
      const normalizedStatuses = (statuses || []).map((status) => String(status).toLowerCase());
      document.querySelectorAll(".run-checkbox").forEach((box) => {
        const row = box.closest("tr");
        if (row?.classList.contains("hidden")) return;
        const statusAttr = (row?.dataset.status || box.dataset.status || "").trim().toLowerCase();
        if (normalizedStatuses.includes(statusAttr)) box.checked = true;
      });
      updateSelectionSizeLabels();
    }

    runsBulkSelectAction?.addEventListener("change", () => {
      const action = runsBulkSelectAction.value;
      if (action === "all") {
        toggleVisibleCheckboxes("#runs_panel_table", ".run-checkbox", true);
      } else if (action === "none") {
        toggleVisibleCheckboxes("#runs_panel_table", ".run-checkbox", false);
      } else if (action === "running") {
        selectRunsByStatuses(["running"]);
      } else if (action === "queued") {
        selectRunsByStatuses(["queued"]);
      } else if (action === "error") {
        selectErrorRuns();
        updateSelectionSizeLabels();
      } else if (action === "canceled") {
        selectRunsByStatuses(["canceled"]);
      } else if (action === "older") {
        const picker = document.getElementById("older_date_picker");
        picker?.showPicker();
      }
      runsBulkSelectAction.value = "";
    });

    let lastChecked = null;
    document.querySelectorAll(".run-checkbox").forEach((box) => {
      box.addEventListener("click", (event) => {
        if (!event.shiftKey || !lastChecked) {
          lastChecked = box;
          return;
        }
        const checkboxes = Array.from(document.querySelectorAll(".run-checkbox"));
        const start = checkboxes.indexOf(box);
        const end = checkboxes.indexOf(lastChecked);
        const [min, max] = start < end ? [start, end] : [end, start];
        for (let i = min; i <= max; i += 1) {
          checkboxes[i].checked = lastChecked.checked;
        }
      });
    });

    function persistAdminRunsFilter(value) {
      fetch("/settings/update", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ admin_runs_filter: value || "__all__" })
      }).catch(() => {});
    }

    selectUserRunsCombo?.addEventListener("change", () => {
      applyAdminRunsFilters();
      updateSelectionSizeLabels();
      persistAdminRunsFilter(selectUserRunsCombo?.value || "__all__");
    });

    adminRunsPatternFilterCombo?.addEventListener("input", () => { applyAdminRunsFilters(); updateSelectionSizeLabels(); });
    adminRunsPatternFilterCombo?.addEventListener("change", () => { persistedExecutionsWildcardHistory = rememberWildcardPattern(adminRunsPatternFilterCombo?.value, "wildcard_history_executions", persistedExecutionsWildcardHistory, document.getElementById("admin_runs_pattern_filter_presets")); applyAdminRunsFilters(); updateSelectionSizeLabels(); });
    adminRunsPatternFilterCombo?.addEventListener("blur", () => { persistedExecutionsWildcardHistory = rememberWildcardPattern(adminRunsPatternFilterCombo?.value, "wildcard_history_executions", persistedExecutionsWildcardHistory, document.getElementById("admin_runs_pattern_filter_presets")); });

    const olderDatePicker = document.getElementById("older_date_picker");
    if (olderDatePicker) {
      olderDatePicker.addEventListener("change", () => {
        const selected = olderDatePicker.value;
        if (!selected) {
          return;
        }
        const threshold = new Date(`${selected}T00:00:00`);
        if (Number.isNaN(threshold.getTime())) {
          return;
        }
        document.querySelectorAll(".run-checkbox").forEach((box) => {
          const startValue = box.dataset.start;
          if (!startValue) {
            return;
          }
          const parts = startValue.split("-");
          const normalized = `${parts[0]}-${parts[1]}-${parts[2]}T${parts[3] || "00:00:00"}`;
          const startDate = new Date(normalized);
          if (!Number.isNaN(startDate.getTime()) && startDate < threshold) {
            box.checked = true;
          }
        });
        olderDatePicker.value = "";
        updateSelectionSizeLabels();
      });
    }

    if (deleteSelectedRunsButton) {
      deleteSelectedRunsButton.addEventListener("click", async () => {
        const ids = getSelectedRunIds();
        if (ids.length === 0) {
          return;
        }
        const ok = await showModal({ title: "Delete executions", message: "This will delete the Uploads and Exports for the selected executions. Continue?", confirmText: "Accept", cancelText: "Cancel" });
        if (!ok) {
          return;
        }
        fetch("/admin/runs/delete", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ ids })
        }).then(() => window.location.reload());
      });
    }

    adminRerunSelectedRunsButton?.addEventListener("click", async () => {
      const ids = getSelectedRunIds();
      if (!ids.length) return;
      const ok = await showModal({ title: "Re-run executions", message: "Queue selected executions as new tasks?", confirmText: "Accept", cancelText: "Cancel" });
      if (!ok) return;
      fetch("/admin/runs/rerun", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ids })
      }).then(() => window.location.reload());
    });

    adminStopSelectedRunsButton?.addEventListener("click", async () => {
      const ids = getSelectedRunIds();
      if (!ids.length) return;
      const ok = await showModal({ title: "Stop executions", message: "Stop selected queued/running tasks?", confirmText: "Accept", cancelText: "Cancel" });
      if (!ok) return;
      fetch("/admin/runs/stop", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ids })
      }).then(() => window.location.reload());
    });


    function uploadAdminInputZip(file, inputName, overwrite = false) {
      const formData = new FormData();
      formData.append("module", "admin-upload");
      formData.append("kind", "input");
      formData.append("session_id", "admin-upload");
      formData.append("input_name", inputName || "");
      formData.append("parent_folder_name", "");
      formData.append("overwrite", overwrite ? "1" : "0");
      formData.append("files", file, file.name || "input.zip");
      return fetch("/uploads/zip", { method: "POST", body: formData }).then((res) => res.json());
    }

    function toInputNameFromZip(fileName) {
      const raw = String(fileName || "uploaded_input.zip").split("/").pop() || "uploaded_input.zip";
      const dot = raw.lastIndexOf(".");
      const stem = dot > 0 ? raw.slice(0, dot) : raw;
      return stem.trim() || "uploaded_input";
    }

    async function processAdminUploadQueue(items) {
      for (const item of items) {
        let uploadResponse = await uploadAdminInputZip(item.file, item.inputName, false);
        if (uploadResponse?.ok) continue;
        if (uploadResponse?.error === "already_exists") {
          const overwriteAnswer = await showModal({
            title: "Input already exists",
            message: `Input ${uploadResponse.existing_name} already exists. Overwrite?`,
            confirmText: "Accept",
            cancelText: "Cancel"
          });
          if (!overwriteAnswer) continue;
          uploadResponse = await uploadAdminInputZip(item.file, item.inputName, true);
        }
      }
      await refreshInputsRepository();
    }

    adminUploadInputsButton?.addEventListener("click", () => adminInputsUploadPicker?.click());

    adminInputsUploadPicker?.addEventListener("change", async () => {
      const files = Array.from(adminInputsUploadPicker.files || []).filter((file) => /\.zip$/i.test(file.name || ""));
      if (!files.length) {
        adminInputsUploadPicker.value = "";
        return;
      }

      if (files.length === 1) {
        const defaultName = toInputNameFromZip(files[0].name);
        const shouldContinue = await showModal({
          title: "Input name",
          message: `Default Input name: ${defaultName}. Do you want to continue and optionally edit it in the next step?`,
          confirmText: "Accept",
          cancelText: "Cancel"
        });
        if (!shouldContinue) {
          adminInputsUploadPicker.value = "";
          return;
        }
        const enteredName = window.prompt("Confirm Input name", defaultName);
        if (enteredName === null) {
          adminInputsUploadPicker.value = "";
          return;
        }
        const selectedName = String(enteredName || "").trim() || defaultName;
        processAdminUploadQueue([{ file: files[0], inputName: selectedName }]).finally(() => {
          adminInputsUploadPicker.value = "";
        });
        return;
      }

      const warningAccepted = await showModal({
        title: "Bulk upload",
        message: "Each Input name will match each uploaded zip filename. Uploads will continue in background.",
        confirmText: "Accept",
        cancelText: "Cancel"
      });
      if (!warningAccepted) {
        adminInputsUploadPicker.value = "";
        return;
      }

      const queueItems = files.map((file) => ({ file, inputName: toInputNameFromZip(file.name) }));
      processAdminUploadQueue(queueItems).finally(() => {
        adminInputsUploadPicker.value = "";
      });
    });

    let adminInputRenameMode = false;

    function enterAdminInputRenameMode() {
      document.querySelectorAll('#inputs_panel_table tbody tr').forEach((row) => {
        const nameCell = row?.cells?.[1];
        if (!nameCell || row.cells.length < 5) return;
        const currentName = (nameCell.textContent || "").trim();
        row.dataset.originalInputName = currentName;
        nameCell.innerHTML = `<input type="text" class="input-name-editor" value="${escapeHtml(currentName)}" />`;
      });
      adminInputRenameMode = true;
      if (renameInputsButton) renameInputsButton.textContent = "Save Rename";
    }

    function exitAdminInputRenameMode() {
      document.querySelectorAll('#inputs_panel_table tbody tr').forEach((row) => {
        const nameCell = row?.cells?.[1];
        if (!nameCell || row.cells.length < 5) return;
        const editor = nameCell.querySelector('.input-name-editor');
        const fallback = row.dataset.originalInputName || "";
        const value = editor ? String(editor.value || fallback).trim() : fallback;
        nameCell.textContent = value || fallback;
      });
      adminInputRenameMode = false;
      if (renameInputsButton) renameInputsButton.textContent = "Rename";
    }

    async function saveAdminInputRenames() {
      const items = [];
      document.querySelectorAll('#inputs_panel_table tbody tr').forEach((row) => {
        if (row.classList.contains('hidden')) return;
        const idValue = row.querySelector('.input-checkbox')?.value;
        const nameCell = row?.cells?.[1];
        const editor = nameCell?.querySelector('.input-name-editor');
        if (!idValue || !editor) return;
        const originalName = (row.dataset.originalInputName || "").trim();
        const newName = String(editor.value || "").trim();
        if (!newName || newName === originalName) return;
        items.push({ id: Number(idValue), new_name: newName });
      });

      if (!items.length) {
        exitAdminInputRenameMode();
        return;
      }

      const response = await fetch('/admin/inputs/rename', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ items })
      });
      const data = await response.json().catch(() => ({ ok: false }));
      if (!data.ok) {
        await showModal({ title: 'Rename inputs', message: data.message || 'Some inputs could not be renamed.', confirmText: 'Accept' });
      }
      await refreshInputsRepository();
      exitAdminInputRenameMode();
      applyAdminInputsFilters();
      updateSelectionSizeLabels();
    }

    function getSelectedInputIds() {
      return Array.from(document.querySelectorAll(".input-checkbox:checked")).map((box) => Number(box.value));
    }
    function persistAdminInputsFilter(value) {
      fetch("/settings/update", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ admin_inputs_filter: value || "__all__" })
      }).catch(() => {});
    }

    selectUserInputsCombo?.addEventListener("change", () => {
      applyAdminInputsFilters();
      updateSelectionSizeLabels();
      persistAdminInputsFilter(selectUserInputsCombo?.value || "__all__");
    });
    adminInputsNameFilterCombo?.addEventListener("input", () => { applyAdminInputsFilters(); updateSelectionSizeLabels(); });
    adminInputsNameFilterCombo?.addEventListener("change", () => { persistedInputsWildcardHistory = rememberWildcardPattern(adminInputsNameFilterCombo?.value, "wildcard_history_inputs", persistedInputsWildcardHistory, document.getElementById("admin_inputs_name_filter_presets")); applyAdminInputsFilters(); updateSelectionSizeLabels(); });
    adminInputsNameFilterCombo?.addEventListener("blur", () => { persistedInputsWildcardHistory = rememberWildcardPattern(adminInputsNameFilterCombo?.value, "wildcard_history_inputs", persistedInputsWildcardHistory, document.getElementById("admin_inputs_name_filter_presets")); });
    renameInputsButton?.addEventListener("click", async () => {
      if (!adminInputRenameMode) {
        enterAdminInputRenameMode();
        return;
      }
      await saveAdminInputRenames();
    });
    inputsBulkSelectAction?.addEventListener("change", () => {
      const action = inputsBulkSelectAction.value;
      if (action === "all") {
        toggleVisibleCheckboxes("#inputs_panel_table", ".input-checkbox", true);
      } else if (action === "none") {
        toggleVisibleCheckboxes("#inputs_panel_table", ".input-checkbox", false);
      } else if (action === "older") {
        olderInputDatePicker?.showPicker();
      }
      inputsBulkSelectAction.value = "";
    });
    olderInputDatePicker?.addEventListener("change", () => {
      const selected = olderInputDatePicker.value;
      if (!selected) return;
      const threshold = new Date(`${selected}T00:00:00`);
      document.querySelectorAll(".input-checkbox").forEach((box) => {
        const raw = box.dataset.uploadedAt || "";
        const d = new Date(raw.replace(/-/g,":"));
        if (!Number.isNaN(d.getTime()) && d < threshold) box.checked = true;
      });
      olderInputDatePicker.value = "";
      updateSelectionSizeLabels();
    });
    deleteSelectedInputsButton?.addEventListener("click", async () => {
      const ids = getSelectedInputIds();
      if (!ids.length) return;
      const ok = await showModal({ title: "Delete inputs", message: "Delete selected inputs?", confirmText: "Accept", cancelText: "Cancel" });
      if (!ok) return;
      fetch("/admin/inputs/delete", {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({ids})}).then(() => window.location.reload());
    });



    function renderAdminLog(text, target, options = {}) {
      if (!target) return;
      const shouldScrollToBottom = Boolean(options.scrollToBottom);
      if (!text) {
        target.textContent = "No logs yet.";
        if (shouldScrollToBottom) target.scrollTop = target.scrollHeight;
        return;
      }
      const lines = text.split(/\r?\n/);
      target.innerHTML = lines.map((line) => {
        let cls = "log-info";
        if (line.includes("[ERROR]")) cls = "log-error";
        else if (line.includes("[WARNING]")) cls = "log-warning";
        else if (line.includes("[DEBUG]")) cls = "log-debug";
        return `<span class="${cls}">${line.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}</span>`;
      }).join("\n");
      if (shouldScrollToBottom) target.scrollTop = target.scrollHeight;
    }

    function copyToClipboard(text) {
      if (!text) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).catch(() => {});
        return;
      }
      const helper = document.createElement("textarea");
      helper.value = text;
      document.body.appendChild(helper);
      helper.select();
      document.execCommand("copy");
      document.body.removeChild(helper);
    }

    function sortByExecutionOrder(a, b) {
      return Number(a.id) - Number(b.id);
    }

    function pickAdminExecutionLogRunId(items, currentRunId) {
      const currentItem = items.find((item) => String(item.id) === String(currentRunId || ""));
      const runningItems = items.filter((item) => item.status_lower === "running").slice().sort(sortByExecutionOrder);
      const cancelingItems = items.filter((item) => item.status_lower === "canceling").slice().sort(sortByExecutionOrder);
      const queuedItems = items.filter((item) => item.status_lower === "queued").slice().sort(sortByExecutionOrder);

      if (currentItem) {
        const currentStatus = String(currentItem.status_lower || "").toLowerCase();
        if (["running", "canceling"].includes(currentStatus)) return String(currentItem.id);
      }
      if (runningItems.length > 0) return String(runningItems[0].id);
      if (cancelingItems.length > 0) return String(cancelingItems[0].id);
      if (queuedItems.length > 0) return String(queuedItems[0].id);
      if (currentItem) return String(currentItem.id);
      return items[0] ? String(items[0].id) : "";
    }

    function fetchAdminRunLog() {
      const runId = adminLogRunSelector?.value;
      if (!runId) {
        renderAdminLog("", adminLogOutput);
        return;
      }
      fetch(buildNoCacheUrl(`/admin/logs/by_run/${runId}`), { cache: "no-store" })
        .then((res) => res.json())
        .then((data) => renderAdminLog(data.log || "", adminLogOutput, { scrollToBottom: adminExecutionLogAuto?.checked }))
        .catch(() => renderAdminLog("", adminLogOutput, { scrollToBottom: adminExecutionLogAuto?.checked }));
    }

    function updateAdminExecutionAutoRefreshAvailability(hasActive) {
      if (!adminExecutionLogAuto) return;
      adminHadActiveTasks = Boolean(hasActive);
      adminExecutionLogAuto.disabled = !hasActive;
      if (!hasActive) {
        setAdminExecutionAutoChecked(false);
        scheduleAdminBackgroundRefresh();
        return;
      }
      if (adminExecutionLogAuto.checked) fetchAdminRunLog();
      persistAdminExecutionAutoCheckedState(adminExecutionLogAuto.checked);
      scheduleAdminBackgroundRefresh();
    }

    function fetchAdminActiveStatus() {
      return fetch(`/admin/runs/active_status?_=${Date.now()}`)
        .then((res) => res.json())
        .then((data) => {
          if (!data.ok) return false;
          const hasActive = Boolean(data.has_active_tasks);
          updateAdminExecutionAutoRefreshAvailability(hasActive);
          return hasActive;
        })
        .catch(() => {
          updateAdminExecutionAutoRefreshAvailability(false);
          return false;
        });
    }

    function buildNoCacheUrl(baseUrl) {
      const separator = baseUrl.includes("?") ? "&" : "?";
      return `${baseUrl}${separator}_=${Date.now()}_${Math.random().toString(36).slice(2)}`;
    }

    function escapeHtml(value) {
      return String(value || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function refreshInputsRepository() {
      return fetch(buildNoCacheUrl("/inputs/list"), { cache: "no-store" })
        .then((res) => res.json())
        .then((data) => {
          if (!data.ok) return;
          const tbody = document.querySelector("#inputs_panel_table tbody");
          if (!tbody) return;

          const selectedIds = new Set(Array.from(document.querySelectorAll(".input-checkbox:checked")).map((box) => Number(box.value)));
          if (!Array.isArray(data.items) || data.items.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5">No inputs yet.</td></tr>';
            populateScopeCombo(selectUserInputsCombo, "#inputs_panel_table", 2);
            applyCurrentOrDefaultSort("#inputs_panel_table table");
            applyAdminInputsFilters();
            updateSelectionSizeLabels();
            return;
          }

          tbody.innerHTML = data.items.map((item) => {
            const checked = selectedIds.has(Number(item.id)) ? "checked" : "";
            return `
              <tr>
                <td><input type="checkbox" class="input-checkbox" value="${escapeHtml(item.id)}" data-uploaded-at="${escapeHtml(item.uploaded_at || "")}" ${checked} /></td>
                <td>${escapeHtml(item.input_name || "—")}</td>
                <td>${escapeHtml(item.uploaded_by || "—")}</td>
                <td>${escapeHtml(item.uploaded_at || "")}</td>
                <td>${escapeHtml(item.size_mb || "0.00 MB")}</td>
              </tr>
            `;
          }).join("");

          populateScopeCombo(selectUserInputsCombo, "#inputs_panel_table", 2);
          applyCurrentOrDefaultSort("#inputs_panel_table table");
          applyAdminInputsFilters();
          updateSelectionSizeLabels();
        })
        .catch(() => {});
    }

    function refreshAdminRunsTable(items) {
      const tbody = document.querySelector("#runs_panel_table tbody");
      if (!tbody) return;

      const selectedIds = new Set(Array.from(document.querySelectorAll(".run-checkbox:checked")).map((box) => Number(box.value)));
      if (!Array.isArray(items) || items.length === 0) {
        tbody.innerHTML = '<tr><td colspan="13">No runs yet.</td></tr>';
        populateScopeCombo(selectUserRunsCombo, "#runs_panel_table", 2);
        applyCurrentOrDefaultSort("#runs_panel_table table");
        applyAdminRunsFilters();
        updateSelectionSizeLabels();
        return;
      }

      tbody.innerHTML = items.map((item) => {
        const rowClass = item.status_lower === "error" ? "run-error" : (item.status_lower === "success" ? "run-success" : "");
        const checked = selectedIds.has(Number(item.id)) ? "checked" : "";
        const outputCell = item.output_zip ? `<a href="/admin/runs/${item.id}/download">Download zip</a>` : "—";
        const logCell = item.output_log_file ? `<a href="/admin/runs/${item.id}/log">Download log</a>` : "—";
        return `
          <tr class="${rowClass}" data-status="${escapeHtml(item.status_lower || "")}">
            <td><input type="checkbox" class="run-checkbox" value="${escapeHtml(item.id)}" data-start="${escapeHtml(item.started_at || "")}" data-status="${escapeHtml(item.status_lower || "")}" ${checked} /></td>
            <td>${escapeHtml(item.id)}</td>
            <td>${escapeHtml(item.username || "—")}</td>
            <td>${escapeHtml(item.module || "—")}</td>
            <td>${escapeHtml(item.tool_version || "—")}</td>
            <td>${escapeHtml(item.input_name || "—")}</td>
            <td>${escapeHtml(item.status_display || "")}</td>
            <td>${escapeHtml(item.started_at || "")}</td>
            <td>${escapeHtml(item.finished_at || "")}</td>
            <td>${escapeHtml(item.duration_hms || "00:00:00")}</td>
            <td>${outputCell}</td>
            <td>${logCell}</td>
            <td>${escapeHtml(item.size_mb || "0.00 MB")}</td>
          </tr>
        `;
      }).join("");

      populateScopeCombo(selectUserRunsCombo, "#runs_panel_table", 2);
      applyCurrentOrDefaultSort("#runs_panel_table table");
      applyAdminRunsFilters();
      updateSelectionSizeLabels();
    }

    function fetchAdminSystemLog() {
      const source = adminSystemLogSource?.value || "app";
      fetch(buildNoCacheUrl(`/logs/system?source=${encodeURIComponent(source)}`), { cache: "no-store" })
        .then((res) => res.json())
        .then((data) => renderAdminLog(data.log || "", adminSystemLogOutput, { scrollToBottom: adminSystemLogAuto?.checked }))
        .catch(() => renderAdminLog("", adminSystemLogOutput, { scrollToBottom: adminSystemLogAuto?.checked }));
    }

    adminLogRunSelector?.addEventListener("change", fetchAdminRunLog);
    adminRefreshLogButton?.addEventListener("click", fetchAdminRunLog);
    adminCopyLogButton?.addEventListener("click", () => copyToClipboard(adminLogOutput?.textContent || ""));
    adminCopySelectionButton?.addEventListener("click", () => copyToClipboard(window.getSelection()?.toString() || ""));

    adminSystemLogSource?.addEventListener("change", () => {
      fetchAdminSystemLog();
      persistAdminSystemLogSource(adminSystemLogSource?.value || "app");
    });
    adminRefreshSystemLogButton?.addEventListener("click", fetchAdminSystemLog);
    adminCopySystemLogButton?.addEventListener("click", () => copyToClipboard(adminSystemLogOutput?.textContent || ""));
    adminCopySystemSelectionButton?.addEventListener("click", () => copyToClipboard(window.getSelection()?.toString() || ""));
    adminDeleteSystemLogButton?.addEventListener("click", async () => {
      const ok = await showModal({ title: "Delete system log", message: "Delete all contents from the selected system log file?", confirmText: "Accept", cancelText: "Cancel" });
      if (!ok) return;
      const source = adminSystemLogSource?.value || "app";
      fetch(`/logs/system/delete?source=${encodeURIComponent(source)}`, { method: "POST" })
        .then((res) => res.json())
        .then((data) => { if (data.ok) renderAdminLog("", adminSystemLogOutput); })
        .catch(() => {});
    });

    let adminDbSnapshot = [];
    let adminDbCurrentPrimaryKeys = [];
    let adminBackgroundRefreshTimer = null;
    let adminSystemLogRefreshTimer = null;
    let adminHasActiveTasks = false;
    let adminHadActiveTasks = false;

    function normalizeDbCellValue(value) {
      if (value === null || value === undefined) return "";
      if (typeof value === "object") return JSON.stringify(value);
      return String(value);
    }

    function buildPrimaryKeyMap(row) {
      const pkMap = {};
      adminDbCurrentPrimaryKeys.forEach((pk) => {
        pkMap[pk] = row[pk];
      });
      return pkMap;
    }

    function renderAdminDbTable(columns, rows, primaryKeys) {
      if (!adminDbEditorTable) return;
      adminDbCurrentPrimaryKeys = Array.isArray(primaryKeys) ? primaryKeys : [];
      adminDbSnapshot = rows.map((row) => ({ ...row }));

      if (!columns || columns.length === 0) {
        adminDbEditorTable.innerHTML = "<thead><tr><th>Select Table</th></tr></thead><tbody><tr><td>Select a table to edit.</td></tr></tbody>";
        return;
      }

      const thead = `<thead><tr>${columns.map((column) => `<th>${column}</th>`).join("")}</tr></thead>`;
      const bodyRows = rows.map((row) => {
        const pkMap = buildPrimaryKeyMap(row);
        return `<tr data-pk='${JSON.stringify(pkMap).replace(/'/g, "&#39;")}'>${columns.map((column) => {
          const isPk = adminDbCurrentPrimaryKeys.includes(column);
          const value = normalizeDbCellValue(row[column]).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
          if (isPk) return `<td><input type="text" class="admin-db-cell" data-column="${column}" value="${value}" disabled /></td>`;
          return `<td><input type="text" class="admin-db-cell" data-column="${column}" value="${value}" /></td>`;
        }).join("")}</tr>`;
      }).join("");

      const tbody = rows.length > 0 ? `<tbody>${bodyRows}</tbody>` : `<tbody><tr><td colspan="${columns.length}">No rows.</td></tr></tbody>`;
      adminDbEditorTable.innerHTML = `${thead}${tbody}`;
    }

    function loadAdminDbTable() {
      const table = adminDbTableSelector?.value;
      if (!table) {
        renderAdminDbTable([], [], []);
        return;
      }
      fetch(`/admin/database/table_data?table=${encodeURIComponent(table)}&_=${Date.now()}`)
        .then((res) => res.json())
        .then((data) => {
          if (!data.ok) {
            renderAdminDbTable([], [], []);
            return;
          }
          renderAdminDbTable(data.columns || [], data.rows || [], data.primary_keys || []);
        })
        .catch(() => renderAdminDbTable([], [], []));
    }

    function collectDbRowUpdates() {
      const updates = [];
      const rows = adminDbEditorTable?.querySelectorAll("tbody tr[data-pk]") || [];
      rows.forEach((tr, idx) => {
        const original = adminDbSnapshot[idx] || {};
        const changedValues = {};
        tr.querySelectorAll(".admin-db-cell").forEach((input) => {
          const column = input.dataset.column;
          if (!column || adminDbCurrentPrimaryKeys.includes(column)) return;
          const nextValue = input.value;
          const originalValue = normalizeDbCellValue(original[column]);
          if (nextValue !== originalValue) changedValues[column] = nextValue;
        });
        if (Object.keys(changedValues).length > 0) {
          const pkMap = JSON.parse(tr.dataset.pk || "{}");
          updates.push({ primary_keys: pkMap, updates: changedValues });
        }
      });
      return updates;
    }

    function applyAdminDbUpdates() {
      const table = adminDbTableSelector?.value;
      if (!table) return;
      const rowUpdates = collectDbRowUpdates();
      if (rowUpdates.length === 0) return;

      Promise.all(rowUpdates.map((rowUpdate) => {
        return fetch("/admin/database/table_update", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            table,
            primary_keys: rowUpdate.primary_keys,
            updates: rowUpdate.updates
          })
        });
      })).then(() => loadAdminDbTable());
    }

    const clearAdminBackgroundRefreshTimer = () => {
      if (adminBackgroundRefreshTimer) {
        clearTimeout(adminBackgroundRefreshTimer);
        adminBackgroundRefreshTimer = null;
      }
    };

    const clearAdminSystemLogRefreshTimer = () => {
      if (adminSystemLogRefreshTimer) {
        clearInterval(adminSystemLogRefreshTimer);
        adminSystemLogRefreshTimer = null;
      }
    };

    const scheduleAdminSystemLogRefresh = () => {
      clearAdminSystemLogRefreshTimer();
      if (!adminSystemLogAuto?.checked) return;
      adminSystemLogRefreshTimer = setInterval(() => {
        fetchAdminSystemLog();
      }, 60000);
    };

    const shouldAdminPollBackground = () => {
      return Boolean(adminExecutionLogAuto?.checked || adminHasActiveTasks);
    };

    const scheduleAdminBackgroundRefresh = () => {
      clearAdminBackgroundRefreshTimer();
      if (!shouldAdminPollBackground()) return;
      adminBackgroundRefreshTimer = setTimeout(runAdminBackgroundRefreshCycle, 3000);
    };

    function runAdminBackgroundRefreshCycle() {
      fetchAdminActiveStatus()
        .then((hasActiveTasks) => {
          adminHasActiveTasks = hasActiveTasks;
          return fetch(buildNoCacheUrl("/admin/runs/list"), { cache: "no-store" })
            .then((res) => res.json())
            .then((data) => {
              if (!data.ok || !Array.isArray(data.items)) return;
              refreshAdminRunsTable(data.items);
              const nextRunId = pickAdminExecutionLogRunId(data.items, adminLogRunSelector?.value || "");
              if (adminLogRunSelector) {
                adminLogRunSelector.innerHTML = data.items.map((item) => `<option value="${item.id}">${escapeHtml(item.run_label || `#${item.id}`)}</option>`).join("");
                if (nextRunId) adminLogRunSelector.value = nextRunId;
              }
              if (adminExecutionLogAuto?.checked) fetchAdminRunLog();
            })
            .catch(() => {});
        })
        .finally(scheduleAdminBackgroundRefresh);
    }

    adminExecutionLogAuto?.addEventListener("change", () => {
      if (adminExecutionLogAuto.checked && !adminHasActiveTasks) {
        setAdminExecutionAutoChecked(false);
        return;
      }
      persistAdminExecutionAutoCheckedState(adminExecutionLogAuto.checked);
      if (adminExecutionLogAuto.checked) fetchAdminRunLog();
      scheduleAdminBackgroundRefresh();
    });

    adminSystemLogAuto?.addEventListener("change", () => {
      persistAdminSystemLogAutoCheckedState(adminSystemLogAuto.checked);
      if (adminSystemLogAuto.checked) fetchAdminSystemLog();
      scheduleAdminSystemLogRefresh();
      scheduleAdminBackgroundRefresh();
    });

    usersFilterCombo?.addEventListener("change", () => {
      applyUsersPanelFilter();
      persistAdminUsersFilter(usersFilterCombo?.value || "all");
    });

    adminDbTableSelector?.addEventListener("change", loadAdminDbTable);
    adminDbReloadTableButton?.addEventListener("click", loadAdminDbTable);
    adminDbCancelChangesButton?.addEventListener("click", loadAdminDbTable);
    adminDbUpdateChangesButton?.addEventListener("click", applyAdminDbUpdates);


    initSortableTable("#users_panel_table table", {
      persistedSort: persistedAdminUsersSort,
      onSortChange: (header, direction) => persistAdminUsersSort(header?.dataset?.sortId || "", direction)
    });
    initSortableTable("#inputs_panel_table table");
    initSortableTable("#runs_panel_table table");
    populateScopeCombo(selectUserInputsCombo, "#inputs_panel_table", 2);
    populateScopeCombo(selectUserRunsCombo, "#runs_panel_table", 2);
    if (selectUserInputsCombo) {
      const hasPersistedInputsFilter = Array.from(selectUserInputsCombo.options || []).some((opt) => opt.value === persistedAdminInputsFilter);
      selectUserInputsCombo.value = hasPersistedInputsFilter ? persistedAdminInputsFilter : "__all__";
    }
    if (selectUserRunsCombo) {
      const hasPersistedRunsFilter = Array.from(selectUserRunsCombo.options || []).some((opt) => opt.value === persistedAdminRunsFilter);
      selectUserRunsCombo.value = hasPersistedRunsFilter ? persistedAdminRunsFilter : "__all__";
    }
    if (inputsTotalSizeLabel) {
      inputsTotalSizeLabel.dataset.totalSize = "{{ inputs_total_size }}";
    }
    if (runsTotalSizeLabel) {
      runsTotalSizeLabel.dataset.totalSize = "{{ global_runs_size }}";
    }
    persistedInputsWildcardHistory = sanitizeWildcardHistory(persistedInputsWildcardHistory);
    persistedExecutionsWildcardHistory = sanitizeWildcardHistory(persistedExecutionsWildcardHistory);
    renderWildcardHistory(document.getElementById("admin_inputs_name_filter_presets"), persistedInputsWildcardHistory);
    renderWildcardHistory(document.getElementById("admin_runs_pattern_filter_presets"), persistedExecutionsWildcardHistory);
    applyCurrentOrDefaultSort("#runs_panel_table table");
    applyCurrentOrDefaultSort("#inputs_panel_table table");
    applyAdminRunsFilters();
    applyAdminInputsFilters();
    document.addEventListener("change", (event) => {
      const target = event.target;
      if (target && (target.classList?.contains("input-checkbox") || target.classList?.contains("run-checkbox"))) {
        updateSelectionSizeLabels();
      }
    });
    if (usersFilterCombo) {
      const hasPersistedOption = Array.from(usersFilterCombo.options || []).some((opt) => opt.value === persistedAdminUsersFilter);
      usersFilterCombo.value = hasPersistedOption ? persistedAdminUsersFilter : "all";
    }
    applyUsersPanelFilter();

    updateSelectionSizeLabels();
    updateConnectedUsersBadge(countConnectedUsersInTable());
    refreshConnectedUsersBadge();
    setInterval(refreshConnectedUsersBadge, 15000);

    refreshInputsRepository();
    runAdminBackgroundRefreshCycle();
    if (adminSystemLogSource) {
      const hasPersistedOption = Array.from(adminSystemLogSource.options || []).some((opt) => opt.value === persistedAdminSystemLogSource);
      adminSystemLogSource.value = hasPersistedOption ? persistedAdminSystemLogSource : "app";
    }

    fetchAdminRunLog();
    fetchAdminSystemLog();
    loadAdminDbTable();
    scheduleAdminSystemLogRefresh();


  </script>
</body>
</html>
