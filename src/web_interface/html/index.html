<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSB Retuning Automations - Web Interface</title>
  <link rel="stylesheet" href="/static/styles.css" />
  <link rel="icon" type="image/png" href="/static/logo_02.png" />
</head>
<body>
  <main class="container">
    <header class="topbar">
      <div>
        <h1>SSB Retuning Automations - Web Interface</h1>
        <div class="header-meta">v{{ tool_meta.version }} - {{ tool_meta.date }}</div>
      </div>
      <nav>
        <div class="user-meta">User: <b>{{ user.username }}</b> ({{ user.role }})</div>
        <div class="nav-links">
          {% if user.role == 'admin' %}<a href="/admin">Admin panel</a>{% endif %}
          <a href="/logout">Sign out</a>
        </div>
      </nav>
    </header>

    <!-- MAIN PANEL (single, full-width) -->
    <section class="card module-card module-main">
      <div class="module-header">
        <img class="module-logo" src="/static/logo_02.png" alt="SSB Retuning Automations logo" />
        <div class="module-title">
          <h2>SSB Retuning Automations</h2>
          <p class="module-eyebrow">Web Interface</p>
          <p class="module-subtitle">1Ô∏è‚É£ Select Module. 2Ô∏è‚É£ Configure Paths & Freqs. 3Ô∏è‚É£ Press Run to execute...</p>
          <div class="doc-inline">
            <div class="doc-inline-title">Documentation:</div>
            <div class="doc-links">
              <a class="doc-link" href="/documentation/user-guide/md?mode=view" target="_blank" rel="noopener">üìù Markdown</a>
              <a class="doc-link" href="/documentation/user-guide/pdf?mode=view" target="_blank" rel="noopener">üìÑ PDF</a>
              <a class="doc-link" href="/documentation/user-guide/docx?mode=download" target="_blank" rel="noopener">üìò Word</a>
              <a class="doc-link" href="/documentation/user-guide/pptx?mode=download" target="_blank" rel="noopener">üìä PowerPoint</a>
              <a class="doc-link" href="/release-notes" target="_blank" rel="noopener">üìú Release Notes</a>
            </div>
          </div>

        </div>
        <div class="module-actions">
          <button type="button" class="btn btn-danger" id="change_password_button">Change Password</button>
          <div class="btn-row">
            <button type="button" class="browse-button" id="load_config_button">Load config.cfg</button>
            <button type="button" class="browse-button" id="export_config_button">Export config.cfg</button>
          </div>
        </div>
      </div>

      <form action="/run" method="post" class="module-form">
        <div class="form-section">
          <p class="section-title">Module to execute</p>
          <label class="label-wide">
            <select name="module" required>
              {% for value, label in module_options %}
                <option value="{{ value }}" {% if settings.get('module') == value %}selected{% endif %}>{{ label }}</option>
              {% endfor %}
            </select>
          </label>
        </div>

        <div class="form-section">
          <p class="section-title">Inputs</p>
          <div class="grid grid-1" id="single-input-row">
            <label>
              <span class="input-with-button">
                <input type="text" name="input" id="input_path" value="{{ settings.get('input', '') }}" placeholder="/path/input" aria-label="Input" />
                <button type="button" class="browse-button upload-button" data-target="input_path" data-file="input_zip" data-kind="input">Upload/Save Input</button>
              </span>
            </label>
          </div>

          <div class="grid grid-1 hidden" id="prepost-input-rows">
            <label>Input PRE
              <span class="input-with-button">
                <input type="text" name="input_pre" id="input_pre_path" value="{{ settings.get('input_pre', '') }}" />
                <button type="button" class="browse-button upload-button" data-target="input_pre_path" data-file="input_pre_zip" data-kind="input_pre">Upload/Save Input</button>
              </span>
            </label>
            <label>Input POST
              <span class="input-with-button">
                <input type="text" name="input_post" id="input_post_path" value="{{ settings.get('input_post', '') }}" />
                <button type="button" class="browse-button upload-button" data-target="input_post_path" data-file="input_post_zip" data-kind="input_post">Upload/Save Input</button>
              </span>
            </label>
          </div>

          <input type="file" id="input_zip" class="hidden" accept=".zip,.log,.txt" multiple />
          <input type="file" id="input_pre_zip" class="hidden" accept=".zip,.log,.txt" multiple />
          <input type="file" id="input_post_zip" class="hidden" accept=".zip,.log,.txt" multiple />
          <input type="file" id="config_picker" class="hidden" accept=".cfg" />
        </div>

        <div class="form-section">
          <p class="section-title">SSB frequencies</p>
          <div class="grid grid-3">
            <label>N77 SSB PRE
              <input type="text" name="n77_ssb_pre" value="{{ settings.get('n77_ssb_pre', '') }}" />
            </label>
            <label>N77 SSB POST
              <input type="text" name="n77_ssb_post" value="{{ settings.get('n77_ssb_post', '') }}" />
            </label>
            <label>N77B SSB
              <input type="text" name="n77b_ssb" value="{{ settings.get('n77b_ssb', '') }}" />
            </label>
          </div>
        </div>

        <div class="form-section">
          <p class="section-title">Allowed SSB and ARFCN lists (comma-separated values)</p>
          <div class="grid grid-2">
            <label>Allowed N77 SSB PRE
              <input type="text" name="allowed_n77_ssb_pre" value="{{ settings.get('allowed_n77_ssb_pre', '') }}" />
            </label>
            <label>Allowed N77 ARFCN PRE
              <input type="text" name="allowed_n77_arfcn_pre" value="{{ settings.get('allowed_n77_arfcn_pre', '') }}" />
            </label>
            <label>Allowed N77 SSB POST
              <input type="text" name="allowed_n77_ssb_post" value="{{ settings.get('allowed_n77_ssb_post', '') }}" />
            </label>
            <label>Allowed N77 ARFCN POST
              <input type="text" name="allowed_n77_arfcn_post" value="{{ settings.get('allowed_n77_arfcn_post', '') }}" />
            </label>
          </div>
        </div>

        <div class="form-section">
          <p class="section-title">Frequency filters</p>
          <div class="freq-selector">
            <div class="freq-fields">
              <label>Configuration Audit filters (empty = no filter)
                <input type="text" name="ca_freq_filters" id="ca_freq_filters" value="{{ settings.get('ca_freq_filters', '') }}" />
              </label>
              <label>Consistency Checks filters (empty = no filter)
                <input type="text" name="cc_freq_filters" id="cc_freq_filters" value="{{ settings.get('cc_freq_filters', '') }}" />
              </label>
            </div>

            <div class="freq-buttons">
              <div class="freq-group">
                <label>Apply to
                  <select id="freq_target">
                    <option value="ca">Configuration Audit</option>
                    <option value="cc">Consistency Checks</option>
                  </select>
                </label>
                <button type="button" id="freq_add" class="btn btn-primary">‚Üê Add</button>
                <button type="button" id="freq_clear" class="btn btn-danger">Clear</button>
                <button type="button" id="freq_remove" class="btn btn-accent">Remove ‚Üí</button>
              </div>
              <button type="button" id="freq_select_all">Select all in list</button>
            </div>

            <div class="freq-list">
              <label>Network frequencies
                <select id="freq_list" multiple size="10">
                  {% for freq in network_frequencies %}
                    <option value="{{ freq }}">{{ freq }}</option>
                  {% endfor %}
                </select>
              </label>
            </div>
          </div>
          <input type="hidden" name="network_frequencies" id="network_frequencies" value="{{ ','.join(network_frequencies) }}" />
        </div>

        <div class="form-section options-section">
          <p class="section-title">Options</p>
          <div class="grid grid-2">
            <label class="checkbox">
              <input type="checkbox" name="profiles_audit" {% if settings.get('profiles_audit') %}checked{% endif %}>
              Profiles Audit
            </label>
            <label class="checkbox">
              <input type="checkbox" name="frequency_audit" {% if settings.get('frequency_audit') %}checked{% endif %}>
              Frequency Audit
            </label>
            <label class="checkbox">
              <input type="checkbox" name="export_correction_cmd" {% if settings.get('export_correction_cmd') %}checked{% endif %}>
              Export Correction Cmd
            </label>
            <label class="checkbox">
              <input type="checkbox" name="fast_excel_export" {% if settings.get('fast_excel_export') %}checked{% endif %}>
              Fast Excel Export
            </label>
          </div>
        </div>

        <div class="form-actions">
          <button type="submit" class="btn btn-success" id="run_module_button">Run Module</button>
          <span class="module-unavailable hidden" id="module_unavailable_message">This module is not available from the Web Interface.</span>
        </div>

        <input type="hidden" name="selected_inputs_single" id="selected_inputs_single" value="" />
        <input type="hidden" name="selected_inputs_pre" id="selected_inputs_pre" value="" />
        <input type="hidden" name="selected_inputs_post" id="selected_inputs_post" value="" />
      </form>

      <span class="run-status hidden" id="run_status" data-latest-status=""></span>
    </section>

    <!-- Inputs Repository -->
    <section class="card">
      <div class="runs-header">
        <div>
          <h2>Inputs Repository</h2>
          <span class="runs-total" id="inputs_total_size">Total size: {{ inputs_total_size }} ¬∑ Selected size: 0.00 MB</span>
        </div>
        <div class="runs-actions">
          <select id="select_user_inputs_combo"><option value="__all__" selected>All Users</option></select>
          <button type="button" id="select_all_inputs">Select All</button>
          <button type="button" id="select_none_inputs">Select None</button>
          <button type="button" id="select_older_inputs">Select Older</button>
          <button type="button" id="send_selected_inputs" class="btn btn-success">Send to Input</button>
          <button type="button" id="delete_selected_inputs" class="btn btn-danger danger-anchor">Delete Selected</button>
          <button type="button" id="toggle_inputs_panel" class="panel-toggle" aria-label="Collapse inputs panel" title="Collapse/Expand">‚ñæ</button>
        </div>
      </div>
      <input type="date" id="older_input_date_picker" class="hidden" />
      <div class="table-scroll history-scroll inputs-scroll" id="inputs_panel_table">
        <table>
          <thead>
            <tr>
              <th></th>
              <th class="sortable" data-sort-key="text">Input</th>
              <th class="sortable" data-sort-key="text">Uploaded by</th>
              <th class="sortable" data-sort-key="datetime" data-default-sort="desc">Uploaded at</th>
              <th class="sortable" data-sort-key="size">Size</th>
              <th class="sortable" data-sort-key="text">Target</th>
            </tr>
          </thead>
          <tbody>
          {% for item in input_items %}
            <tr>
              <td><input type="checkbox" class="input-checkbox" value="{{ item.id }}" data-uploaded-at="{{ item.uploaded_at }}" /></td>
              <td>{{ item.input_name }}</td>
              <td>{{ item.uploaded_by }}</td>
              <td>{{ item.uploaded_at }}</td>
              <td>{{ item.size_mb }}</td>
              <td data-input-path="{{ item.input_path }}">
                <select class="send-target">
                  <option value="single">Single Input</option>
                  <option value="pre">Input PRE</option>
                  <option value="post">Input POST</option>
                </select>
              </td>
            </tr>
          {% else %}
            <tr><td colspan="6">No inputs in repository.</td></tr>
          {% endfor %}
          </tbody>
        </table>
      </div>
    </section>

    <!-- Executions History -->
    <section class="card">
      <div class="runs-header">
        <div>
          <h2>Executions History</h2>
          <span class="runs-total" id="runs_total_size">Total size: {{ total_runs_size }} ¬∑ Selected size: 0.00 MB</span>
        </div>
        <div class="runs-actions">
          <select id="select_user_runs_combo"><option value="{{ user.username }}" selected>{{ user.username }}</option></select>
          <button type="button" id="select_all_runs">Select All</button>
          <button type="button" id="select_none_runs">Select None</button>
          <button type="button" id="select_running_queued_runs">Select Running/Queued</button>
          <button type="button" id="select_cancelled_runs">Select Cancelled</button>
          <button type="button" id="select_older_runs">Select Older</button>
          <button type="button" id="select_error_runs">Select Error</button>
          <button type="button" id="stop_selected_runs" class="btn btn-danger danger-anchor">Stop Selected</button>
          <button type="button" id="delete_selected_runs" class="btn btn-danger">Delete Selected</button>
          <button type="button" id="toggle_runs_panel" class="panel-toggle" aria-label="Collapse runs panel" title="Collapse/Expand">‚ñæ</button>
        </div>
      </div>

      <input type="date" id="older_date_picker" class="hidden" />
      <div class="latest-runs-scroll history-scroll runs-scroll" id="runs_panel_table">
        <table>
          <thead>
            <tr>
              <th></th>
              <th class="sortable" data-sort-key="number" data-default-sort="desc">ID</th>
              <th class="sortable" data-sort-key="text">Module</th>
              <th class="sortable" data-sort-key="text">Version</th>
              <th class="sortable" data-sort-key="text">Input</th>
              <th class="sortable" data-sort-key="text">Status</th>
              <th class="sortable" data-sort-key="datetime">Start</th>
              <th class="sortable" data-sort-key="datetime">End</th>
              <th class="sortable" data-sort-key="duration">Duration</th>
              <th class="sortable" data-sort-key="text">Output</th>
              <th class="sortable" data-sort-key="text">Log</th>
              <th class="sortable" data-sort-key="size">Size</th>
            </tr>
          </thead>
          <tbody>
          {% for r in latest_runs %}
            <tr class="run-row {% if r.status_lower == 'error' %}run-error{% elif r.status_lower == 'success' %}run-success{% elif r.status_lower == 'canceled' %}run-canceled{% endif %}"
                data-run-id="{{ r.id }}" data-status="{{ r.status_lower }}" data-run-user="{{ user.username }}">
              <td><input type="checkbox" class="run-checkbox" value="{{ r.id }}" data-start="{{ r.started_at }}" data-status="{{ r.status_lower }}" /></td>
              <td>{{ r.id }}</td>
              <td>{{ r.module }}</td>
              <td>{{ r.tool_version or '‚Äî' }}</td>
              <td>{{ r.input_name or "‚Äî" }}</td>
              <td class="run-status-cell">{{ r.status_display }}</td>
              <td class="run-start-cell">{{ r.started_at }}</td>
              <td class="run-finished-cell">{{ r.finished_at }}</td>
              <td class="run-duration-cell">{{ r.duration_hms }}</td>
              <td class="run-output-cell">
                {% if r.output_zip %}
                  <a href="/runs/{{ r.id }}/download">Download zip</a>
                {% else %}
                  ‚Äî
                {% endif %}
              </td>
              <td class="run-log-cell">
                {% if r.output_log_file %}
                  <a href="/runs/{{ r.id }}/log">Download log</a>
                {% else %}
                  ‚Äî
                {% endif %}
              </td>
              <td>{{ r.size_mb }}</td>
            </tr>
          {% else %}
            <tr><td colspan="12">No executions yet.</td></tr>
          {% endfor %}
          </tbody>
        </table>
      </div>
    </section>

    <!-- Execution Logs -->
    <section class="card log-card">
      <div class="log-header">
        <h2>Executions Logs</h2>
        <div class="log-actions">
          <select id="log_run_selector">
            {% for r in latest_runs %}
              <option value="{{ r.id }}" {% if loop.first %}selected{% endif %}>{{ r.run_label }}</option>
            {% endfor %}
          </select>
          <label class="checkbox">
            <input type="checkbox" id="execution_log_auto" disabled />
            Auto refresh
          </label>
          <button type="button" id="refresh_log">Refresh</button>
          <button type="button" id="copy_log">Copy all</button>
          <button type="button" id="copy_selection">Copy selection</button>
          <button type="button" id="toggle_execution_log_panel" class="panel-toggle" aria-label="Collapse execution log panel" title="Collapse/Expand">‚ñæ</button>
        </div>
      </div>
      <pre id="log_output" class="log-output">No logs yet.</pre>
    </section>

    <!-- System Logs -->
    <section class="card log-card">
      <div class="log-header">
        <h2>System Logs</h2>
        <div class="log-actions">
          <select id="system_log_source">
            <option value="app" selected>Application</option>
            <option value="api">API</option>
          </select>
          <label class="checkbox">
            <input type="checkbox" id="system_log_auto" />
            Auto refresh
          </label>
          <button type="button" id="refresh_system_log">Refresh</button>
          <button type="button" id="copy_system_log">Copy all</button>
          <button type="button" id="copy_system_selection">Copy selection</button>
          <button type="button" id="toggle_system_log_panel" class="panel-toggle" aria-label="Collapse system log panel" title="Collapse/Expand">‚ñæ</button>
        </div>
      </div>
      <pre id="system_log_output" class="log-output">No logs yet.</pre>
    </section>
  </main>

  <!-- JS: unchanged except it no longer references documentation-side -->
  <script>
    const moduleSelect = document.querySelector('select[name="module"]');
    const singleInputRow = document.getElementById("single-input-row");
    const prepostInputRows = document.getElementById("prepost-input-rows");

    const uploadInputs = {
      input_zip: document.getElementById("input_zip"),
      input_pre_zip: document.getElementById("input_pre_zip"),
      input_post_zip: document.getElementById("input_post_zip")
    };
    const loadConfigButton = document.getElementById("load_config_button");
    const exportConfigButton = document.getElementById("export_config_button");
    const changePasswordButton = document.getElementById("change_password_button");
    const refreshLogButton = document.getElementById("refresh_log");
    const copyLogButton = document.getElementById("copy_log");
    const copySelectionButton = document.getElementById("copy_selection");
    const toggleExecutionLogPanelButton = document.getElementById("toggle_execution_log_panel");
    const executionLogAuto = document.getElementById("execution_log_auto");
    const logOutput = document.getElementById("log_output");
    const logRunSelector = document.getElementById("log_run_selector");
    const configPicker = document.getElementById("config_picker");
    const selectUserRunsCombo = document.getElementById("select_user_runs_combo");
    const selectOlderRunsButton = document.getElementById("select_older_runs");
    const selectAllRunsButton = document.getElementById("select_all_runs");
    const selectNoneRunsButton = document.getElementById("select_none_runs");
    const selectRunningQueuedRunsButton = document.getElementById("select_running_queued_runs");
    const selectCancelledRunsButton = document.getElementById("select_cancelled_runs");
    const selectErrorRunsButton = document.getElementById("select_error_runs");
    const stopSelectedRunsButton = document.getElementById("stop_selected_runs");
    const deleteSelectedRunsButton = document.getElementById("delete_selected_runs");
    const runStatusLabel = document.getElementById("run_status");
    const runModuleButton = document.getElementById("run_module_button");
    const moduleUnavailableMessage = document.getElementById("module_unavailable_message");
    const systemLogOutput = document.getElementById("system_log_output");
    const systemLogSource = document.getElementById("system_log_source");
    const systemLogAuto = document.getElementById("system_log_auto");
    const refreshSystemLogButton = document.getElementById("refresh_system_log");
    const copySystemLogButton = document.getElementById("copy_system_log");
    const copySystemSelectionButton = document.getElementById("copy_system_selection");
    const toggleSystemLogPanelButton = document.getElementById("toggle_system_log_panel");
    const selectOlderInputsButton = document.getElementById("select_older_inputs");
    const selectUserInputsCombo = document.getElementById("select_user_inputs_combo");
    const selectAllInputsButton = document.getElementById("select_all_inputs");
    const selectNoneInputsButton = document.getElementById("select_none_inputs");
    const sendSelectedInputsButton = document.getElementById("send_selected_inputs");
    const deleteSelectedInputsButton = document.getElementById("delete_selected_inputs");
    const olderInputDatePicker = document.getElementById("older_input_date_picker");
    const toggleInputsPanelButton = document.getElementById("toggle_inputs_panel");
    const inputsPanelTable = document.getElementById("inputs_panel_table");
    let runsRefreshInFlight = false;
    let runsRefreshPromise = null;
    let hasActiveTasks = false;
    let backgroundRefreshTimer = null;
    let systemLogRefreshTimer = null;
    const updateNetworkFrequenciesModule = "update-network-frequencies";
    let lastAppliedNetworkFrequenciesRunMarker = "";
    let networkFrequenciesRefreshInFlight = null;
    const EXECUTION_AUTO_ENABLE_PENDING_KEY = "execution_log_auto_enable_pending";
    const EXECUTION_AUTO_CHECKED_KEY = "execution_log_auto_checked";
    let pendingExecutionAutoEnable = false;
    let persistedExecutionAutoChecked = false;
    try {
      pendingExecutionAutoEnable = window.sessionStorage?.getItem(EXECUTION_AUTO_ENABLE_PENDING_KEY) === "1";
      persistedExecutionAutoChecked = window.sessionStorage?.getItem(EXECUTION_AUTO_CHECKED_KEY) === "1";
    } catch (_error) {
      pendingExecutionAutoEnable = false;
      persistedExecutionAutoChecked = false;
    }
    const inputsTotalSizeLabel = document.getElementById("inputs_total_size");
    const runsTotalSizeLabel = document.getElementById("runs_total_size");
    const currentUsername = "{{ user.username }}";

    const inputFields = {
      input: document.getElementById("input_path"),
      input_pre: document.getElementById("input_pre_path"),
      input_post: document.getElementById("input_post_path"),
      n77_ssb_pre: document.querySelector('input[name="n77_ssb_pre"]'),
      n77_ssb_post: document.querySelector('input[name="n77_ssb_post"]'),
      n77b_ssb: document.querySelector('input[name="n77b_ssb"]'),
      allowed_n77_ssb_pre: document.querySelector('input[name="allowed_n77_ssb_pre"]'),
      allowed_n77_arfcn_pre: document.querySelector('input[name="allowed_n77_arfcn_pre"]'),
      allowed_n77_ssb_post: document.querySelector('input[name="allowed_n77_ssb_post"]'),
      allowed_n77_arfcn_post: document.querySelector('input[name="allowed_n77_arfcn_post"]'),
      ca_freq_filters: document.querySelector('input[name="ca_freq_filters"]'),
      cc_freq_filters: document.querySelector('input[name="cc_freq_filters"]'),
      profiles_audit: document.querySelector('input[name="profiles_audit"]'),
      frequency_audit: document.querySelector('input[name="frequency_audit"]'),
      export_correction_cmd: document.querySelector('input[name="export_correction_cmd"]'),
      fast_excel_export: document.querySelector('input[name="fast_excel_export"]')
    };
    const freqList = document.getElementById("freq_list");
    const networkFrequenciesField = document.getElementById("network_frequencies");
    const caFiltersInput = document.getElementById("ca_freq_filters");
    const ccFiltersInput = document.getElementById("cc_freq_filters");
    const freqTargetSelect = document.getElementById("freq_target");
    const freqAddButton = document.getElementById("freq_add");
    const freqRemoveButton = document.getElementById("freq_remove");
    const freqClearButton = document.getElementById("freq_clear");
    const selectAllButton = document.getElementById("freq_select_all");
    const blockedModuleValue = "consistency-check-bulk";
    const toggleRunsPanelButton = document.getElementById("toggle_runs_panel");
    const runsPanelTable = document.getElementById("runs_panel_table");
    const selectedInputsSingleField = document.getElementById("selected_inputs_single");
    const selectedInputsPreField = document.getElementById("selected_inputs_pre");
    const selectedInputsPostField = document.getElementById("selected_inputs_post");

    function markExecutionAutoEnablePending() {
      pendingExecutionAutoEnable = true;
      try {
        window.sessionStorage?.setItem(EXECUTION_AUTO_ENABLE_PENDING_KEY, "1");
      } catch (_error) {
        // ignore storage errors
      }
    }

    function clearExecutionAutoEnablePending() {
      pendingExecutionAutoEnable = false;
      try {
        window.sessionStorage?.removeItem(EXECUTION_AUTO_ENABLE_PENDING_KEY);
      } catch (_error) {
        // ignore storage errors
      }
    }

    function persistExecutionAutoCheckedState(isChecked) {
      persistedExecutionAutoChecked = Boolean(isChecked);
      try {
        window.sessionStorage?.setItem(EXECUTION_AUTO_CHECKED_KEY, persistedExecutionAutoChecked ? "1" : "0");
      } catch (_error) {
        // ignore storage errors
      }
    }

    function setExecutionAutoChecked(isChecked) {
      if (!executionLogAuto) return;
      executionLogAuto.checked = Boolean(isChecked);
      persistExecutionAutoCheckedState(executionLogAuto.checked);
    }

    if (executionLogAuto) {
      executionLogAuto.checked = persistedExecutionAutoChecked;
    }

    function toggleInputRows() {
      const isConsistencyCheck = moduleSelect.value === "consistency-check";
      singleInputRow.classList.toggle("hidden", isConsistencyCheck);
      prepostInputRows.classList.toggle("hidden", !isConsistencyCheck);
      selectedInputsSingleField.value = "";
      selectedInputsPreField.value = "";
      selectedInputsPostField.value = "";
    }

    function buildRepositoryPath(inputName) {
      return `/workspace/SSB_RetuningAutomations/data/inputs/${inputName}`;
    }

    function parseCsvList(raw) {
      return (raw || "").split(",").map((item) => item.trim()).filter((item) => item);
    }

    function inferParentFolderName(files) {
      if (!files || !files.length) return "uploaded_input";
      const first = files[0];
      const relativePath = first.webkitRelativePath || "";
      if (relativePath.includes("/")) return relativePath.split("/")[0] || "uploaded_input";
      const firstName = first.name || "uploaded_input";
      const dot = firstName.lastIndexOf(".");
      return (dot > 0 ? firstName.slice(0, dot) : firstName) || "uploaded_input";
    }

    function buildBatchListHtml(items) {
      const listItems = items.map((item) => `<li>${escapeHtml(item)}</li>`).join("");
      return `<div class="modal-list-wrapper"><strong>Queued folders:</strong><ul class="modal-list">${listItems}</ul></div>`;
    }

    function parseSortableValue(rawValue, sortType) {
      const value = (rawValue || "").trim();
      if (sortType === "size") {
        const n = Number.parseFloat(value.replace(/[^0-9.]/g, ""));
        return Number.isNaN(n) ? -1 : n;
      }
      if (sortType === "duration") {
        const parts = value.split(":").map((item) => Number.parseInt(item, 10));
        if (parts.length === 3 && parts.every((item) => !Number.isNaN(item))) return (parts[0] * 3600) + (parts[1] * 60) + parts[2];
        return -1;
      }
      if (sortType === "datetime") {
        const normalized = value.replace(/^(\d{4})-(\d{2})-(\d{2})-(\d{2}:\d{2}:\d{2})$/, "$1-$2-$3T$4");
        const ts = Date.parse(normalized);
        return Number.isNaN(ts) ? -1 : ts;
      }
      return value.toLowerCase();
    }

    function sortTableByHeader(table, header, forcedDirection = null) {
      const tbody = table?.querySelector("tbody");
      if (!tbody || !header) return;
      const rows = Array.from(tbody.querySelectorAll("tr"));
      if (rows.length <= 1) return;

      const headers = Array.from(table.querySelectorAll("thead th.sortable"));
      const columnIndex = Array.from(header.parentElement.children).indexOf(header);
      headers.forEach((other) => {
        if (!other.dataset.label) other.dataset.label = other.textContent.replace(/\s*[‚ñ≤‚ñº]$/, "").trim();
      });

      headers.forEach((other) => {
        if (other !== header) {
          other.dataset.sortDirection = "none";
          other.textContent = other.dataset.label || other.textContent.replace(/\s*[‚ñ≤‚ñº]$/, "").trim();
        }
      });

      const currentDirection = forcedDirection || (header.dataset.sortDirection === "asc" ? "desc" : "asc");
      header.dataset.sortDirection = currentDirection;
      const sortType = header.dataset.sortKey || "text";
      const baseLabel = header.dataset.label || header.textContent.replace(/\s*[‚ñ≤‚ñº]$/, "").trim();
      header.textContent = `${baseLabel} ${currentDirection === "asc" ? "‚ñ≤" : "‚ñº"}`;

      rows.sort((rowA, rowB) => {
        const aCell = rowA.cells[columnIndex];
        const bCell = rowB.cells[columnIndex];
        const aText = aCell ? aCell.textContent : "";
        const bText = bCell ? bCell.textContent : "";
        const aValue = parseSortableValue(aText, sortType);
        const bValue = parseSortableValue(bText, sortType);
        if (aValue < bValue) return currentDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return currentDirection === "asc" ? 1 : -1;
        return 0;
      });

      rows.forEach((row) => tbody.appendChild(row));
    }

    function applyCurrentOrDefaultSort(tableSelector) {
      const table = document.querySelector(tableSelector);
      if (!table) return;
      const headers = Array.from(table.querySelectorAll("thead th.sortable"));
      const activeHeader = headers.find((header) => ["asc", "desc"].includes(header.dataset.sortDirection));
      if (activeHeader) {
        sortTableByHeader(table, activeHeader, activeHeader.dataset.sortDirection);
        return;
      }
      const defaultHeader = headers.find((header) => header.dataset.defaultSort);
      if (defaultHeader) sortTableByHeader(table, defaultHeader, defaultHeader.dataset.defaultSort);
    }

    function initSortableTable(tableSelector) {
      const table = document.querySelector(tableSelector);
      if (!table) return;
      const headers = Array.from(table.querySelectorAll("thead th.sortable"));
      headers.forEach((header) => {
        header.dataset.sortDirection = "none";
        header.dataset.label = header.textContent.replace(/\s*[‚ñ≤‚ñº]$/, "").trim();
        header.title = "Sort";
        header.addEventListener("click", () => sortTableByHeader(table, header));
      });
      applyCurrentOrDefaultSort(tableSelector);
    }

    function refreshInputsRepository() {
      return fetch("/inputs/list")
        .then((res) => res.json())
        .then(async (data) => {
          if (!data.ok) return;

          if (inputsTotalSizeLabel && data.total_size) inputsTotalSizeLabel.dataset.totalSize = data.total_size;

          const tbody = document.querySelector("#inputs_panel_table tbody");
          if (!tbody) return;

          if (!data.items || data.items.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6">No inputs in repository.</td></tr>';
            applyCurrentOrDefaultSort("#inputs_panel_table table");
            populateInputScopeSelector();
            updateSelectionSizeLabels();
            return;
          }

          tbody.innerHTML = data.items.map((item) => `
            <tr>
              <td><input type="checkbox" class="input-checkbox" value="${item.id}" data-uploaded-at="${item.uploaded_at}" /></td>
              <td>${escapeHtml(item.input_name)}</td>
              <td>${escapeHtml(item.uploaded_by)}</td>
              <td>${escapeHtml(item.uploaded_at)}</td>
              <td>${escapeHtml(item.size_mb)}</td>
              <td data-input-path="${escapeHtml(item.input_path || "")}">
                <select class="send-target">
                  <option value="single">Single Input</option>
                  <option value="pre">Input PRE</option>
                  <option value="post">Input POST</option>
                </select>
              </td>
            </tr>
          `).join("");

          applyCurrentOrDefaultSort("#inputs_panel_table table");
          populateInputScopeSelector();
          applyScopeFilter("#inputs_panel_table", (row) => row?.cells?.[2]?.textContent?.trim() || "", selectUserInputsCombo?.value);
          updateSelectionSizeLabels();
        })
        .catch(() => {});
    }

    function populateScopeCombo(combo, users, options = {}) {
      if (!combo) return;
      const previous = combo.value;
      const includeAll = options.includeAll !== false;
      const fallback = options.fallback || "__all__";
      const uniqueUsers = Array.from(new Set(users.filter((value) => value && value !== "‚Äî"))).sort((a, b) => a.localeCompare(b));
      const allOption = includeAll ? '<option value="__all__">All Users</option>' : "";
      combo.innerHTML = allOption + uniqueUsers.map((user) => `<option value="${escapeHtml(user)}">${escapeHtml(user)}</option>`).join("");
      if (uniqueUsers.includes(previous) || (includeAll && previous === "__all__")) {
        combo.value = previous;
      } else if (uniqueUsers.includes(fallback) || (includeAll && fallback === "__all__")) {
        combo.value = fallback;
      } else if (uniqueUsers.length > 0) {
        combo.value = uniqueUsers[0];
      }
    }

    function applyScopeFilter(tableSelector, getRowUser, selectedValue) {
      const mode = selectedValue || "__all__";
      document.querySelectorAll(`${tableSelector} tbody tr`).forEach((row) => {
        const rowUser = getRowUser(row);
        const shouldShow = mode === "__all__" || rowUser === mode;
        row.classList.toggle("hidden", !shouldShow);
      });
    }

    function toggleVisibleCheckboxes(tableSelector, checkboxSelector, checked) {
      document.querySelectorAll(`${tableSelector} tbody tr`).forEach((row) => {
        if (row.classList.contains("hidden")) return;
        const box = row.querySelector(checkboxSelector);
        if (box) box.checked = checked;
      });
      updateSelectionSizeLabels();
    }

    function parseSizeMb(value) {
      if (!value) return 0;
      const cleaned = String(value).replace(',', '.');
      const match = cleaned.match(/([\d.]+)/);
      return match ? Number(match[1]) || 0 : 0;
    }

    function formatSizeMb(valueMb) {
      return `${valueMb.toFixed(2)} MB`;
    }

    function updateSelectionSizeLabels() {
      if (inputsTotalSizeLabel) {
        let visibleTotalMb = 0;
        let selectedMb = 0;
        document.querySelectorAll('#inputs_panel_table tbody tr').forEach((row) => {
          if (row.classList.contains('hidden')) return;
          const rowSize = parseSizeMb(row?.cells?.[4]?.textContent || '0 MB');
          visibleTotalMb += rowSize;
          const box = row.querySelector('.input-checkbox');
          if (box?.checked) selectedMb += rowSize;
        });
        inputsTotalSizeLabel.textContent = `Total size: ${formatSizeMb(visibleTotalMb)} ¬∑ Selected size: ${formatSizeMb(selectedMb)}`;
      }
      if (runsTotalSizeLabel) {
        let visibleTotalMb = 0;
        let selectedMb = 0;
        document.querySelectorAll('#runs_panel_table tbody tr').forEach((row) => {
          if (row.classList.contains('hidden')) return;
          const rowSize = parseSizeMb(row?.cells?.[11]?.textContent || '0 MB');
          visibleTotalMb += rowSize;
          const box = row.querySelector('.run-checkbox');
          if (box?.checked) selectedMb += rowSize;
        });
        runsTotalSizeLabel.textContent = `Total size: ${formatSizeMb(visibleTotalMb)} ¬∑ Selected size: ${formatSizeMb(selectedMb)}`;
      }
    }

    function populateInputScopeSelector() {
      const users = Array.from(document.querySelectorAll("#inputs_panel_table tbody tr"))
        .map((row) => row.cells?.[2]?.textContent?.trim() || "");
      populateScopeCombo(selectUserInputsCombo, users, { includeAll: true, fallback: "__all__" });
    }

    function populateRunScopeSelector() {
      const users = Array.from(document.querySelectorAll("#runs_panel_table tbody tr"))
        .map((row) => row.dataset.runUser || currentUsername);
      populateScopeCombo(selectUserRunsCombo, users, { includeAll: false, fallback: currentUsername });
    }

    function collectSelectedInputsByTarget() {
      const selected = { single: [], pre: [], post: [] };
      Array.from(document.querySelectorAll(".input-checkbox:checked")).forEach((box) => {
        const row = box.closest("tr");
        const rowTarget = row?.querySelector(".send-target")?.value || "single";
        const inputName = row?.cells?.[1]?.textContent?.trim() || "";
        const inputPath = row?.cells?.[5]?.dataset?.inputPath || "";
        const value = inputPath || buildRepositoryPath(inputName);
        if (value && selected[rowTarget]) selected[rowTarget].push(value);
      });
      return selected;
    }

    function isModuleBlocked() {
      return moduleSelect.value === blockedModuleValue;
    }

    function updateModuleAvailability() {
      if (!runModuleButton || !moduleUnavailableMessage) return;
      const blocked = isModuleBlocked();
      runModuleButton.disabled = blocked;
      moduleUnavailableMessage.classList.toggle("hidden", !blocked);
    }

    function showModal({ title = "Notice", message = "", messageHtml = "", confirmText = "Accept", cancelText = "", showInput = false, inputValue = "", inputPlaceholder = "", tone = "info" }) {
      return new Promise((resolve) => {
        const backdrop = document.createElement("div");
        backdrop.className = "modal-backdrop";
        const box = document.createElement("div");
        box.className = "modal-box";
        const titleEl = document.createElement("h3");
        titleEl.className = "modal-title";
        titleEl.textContent = title;

        const messageEl = document.createElement("p");
        messageEl.className = "modal-message";
        if (tone === "error") messageEl.classList.add("modal-message-error");
        if (messageHtml) messageEl.innerHTML = messageHtml;
        else messageEl.textContent = message;

        box.appendChild(titleEl);
        box.appendChild(messageEl);

        let inputEl = null;
        if (showInput) {
          inputEl = document.createElement("input");
          inputEl.type = "text";
          inputEl.className = "modal-input";
          inputEl.value = inputValue;
          inputEl.placeholder = inputPlaceholder;
          box.appendChild(inputEl);
        }

        const actions = document.createElement("div");
        actions.className = "modal-actions";

        if (cancelText) {
          const cancelBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.className = "btn btn-danger";
          cancelBtn.textContent = cancelText;
          cancelBtn.addEventListener("click", () => {
            backdrop.remove();
            resolve({ ok: false, value: null });
          });
          actions.appendChild(cancelBtn);
        }

        const okBtn = document.createElement("button");
        okBtn.type = "button";
        okBtn.className = "btn btn-primary";
        okBtn.textContent = confirmText;
        okBtn.addEventListener("click", () => {
          const value = inputEl ? inputEl.value : null;
          backdrop.remove();
          resolve({ ok: true, value });
        });
        actions.appendChild(okBtn);

        box.appendChild(actions);
        backdrop.appendChild(box);
        document.body.appendChild(backdrop);

        if (inputEl) {
          inputEl.focus();
          inputEl.select();
        }
      });
    }

    function uploadZip(files, moduleValue, kindValue, inputName, overwrite, parentFolderName = "") {
      const formData = new FormData();
      Array.from(files).forEach((file) => {
        const uploadName = file.webkitRelativePath || file.name;
        formData.append("files", file, uploadName);
      });
      formData.append("module", moduleValue);
      formData.append("kind", kindValue);
      formData.append("session_id", uploadSessionId);
      formData.append("input_name", inputName || "");
      formData.append("parent_folder_name", parentFolderName || "");
      formData.append("overwrite", overwrite ? "1" : "0");
      return fetch("/uploads/zip", { method: "POST", body: formData }).then((res) => res.json());
    }

    document.querySelectorAll(".upload-button").forEach((button) => {
      button.addEventListener("click", () => {
        const fileInput = uploadInputs[button.dataset.file];
        if (fileInput) fileInput.click();
      });
    });

    Object.entries(uploadInputs).forEach(([inputId, inputElement]) => {
      inputElement.addEventListener("change", async () => {
        const files = inputElement.files;
        if (!files || files.length === 0) return;

        const button = document.querySelector(`[data-file="${inputId}"]`);
        const targetInput = button ? document.getElementById(button.dataset.target) : null;
        const kindValue = button ? button.dataset.kind : "";
        if (!targetInput || !kindValue) return;

        const inferredParentFolderName = inferParentFolderName(Array.from(files));
        const defaultInputName = inferredParentFolderName || "uploaded_input";
        const modalInput = await showModal({
          title: "Input name",
          message: "Input name for repository",
          confirmText: "Accept",
          cancelText: "Cancel",
          showInput: true,
          inputValue: defaultInputName
        });

        let selectedInputName = modalInput.value;
        if (!modalInput.ok || selectedInputName === null) { inputElement.value = ""; return; }

        selectedInputName = (selectedInputName || "").trim() || defaultInputName;

        targetInput.value = "Uploading...";
        uploadZip(files, moduleSelect.value, kindValue, selectedInputName, false, inferredParentFolderName)
          .then(async (data) => {
            if (data.ok && data.path) {
              targetInput.value = data.path;
              scheduleAutoSave();
              refreshInputsRepository();
              return;
            }
            if (data.error === "already_exists") {
              const overwriteResponse = await showModal({
                title: "Input already exists",
                message: `Input ${data.existing_name} already exists. Overwrite?`,
                confirmText: "Accept",
                cancelText: "Cancel"
              });
              if (overwriteResponse.ok) {
                uploadZip(files, moduleSelect.value, kindValue, selectedInputName, true, inferredParentFolderName).then((retry) => {
                  if (retry.ok && retry.path) {
                    targetInput.value = retry.path;
                    scheduleAutoSave();
                    refreshInputsRepository();
                  }
                });
              } else {
                targetInput.value = "";
              }
              return;
            }
            targetInput.value = "";
          })
          .catch(() => { targetInput.value = ""; })
          .finally(() => { inputElement.value = ""; });
      });
    });

    function toBool(value) {
      if (!value) return false;
      return ["true", "1", "yes", "on"].includes(value.toLowerCase());
    }

    function normalizeConfig(config) {
      const source = config.general || config || {};
      const keyMap = {
        last_input_dir: "last_input",
        last_input_dir_audit: "last_input_audit",
        last_input_dir_cc_pre: "last_input_cc_pre",
        last_input_dir_cc_post: "last_input_cc_post",
        last_input_dir_cc_bulk: "last_input_cc_bulk",
        last_input_dir_final_cleanup: "last_input_final_cleanup",
        allowed_n77_ssb_pre_csv: "allowed_n77_ssb_pre",
        allowed_n77_arfcn_pre_csv: "allowed_n77_arfcn_pre",
        allowed_n77_ssb_post_csv: "allowed_n77_ssb_post",
        allowed_n77_arfcn_post_csv: "allowed_n77_arfcn_post"
      };
      const normalized = { ...source };
      Object.entries(keyMap).forEach(([rawKey, logicalKey]) => {
        if (rawKey in source && !(logicalKey in normalized)) normalized[logicalKey] = source[rawKey];
      });
      return normalized;
    }

    function refreshNetworkFrequenciesFromConfig() {
      if (networkFrequenciesRefreshInFlight) return networkFrequenciesRefreshInFlight;
      networkFrequenciesRefreshInFlight = fetch(buildNoCacheUrl("/config/load"), { cache: "no-store" })
        .then((res) => res.json())
        .then((data) => {
          const general = normalizeConfig(data);
          if (!general.network_frequencies) return;
          updateNetworkFrequencies(parseCsv(general.network_frequencies));
        })
        .catch(() => {})
        .finally(() => {
          networkFrequenciesRefreshInFlight = null;
        });
      return networkFrequenciesRefreshInFlight;
    }

    function syncNetworkFrequenciesAfterModule0Run(items) {
      if (!Array.isArray(items) || items.length === 0) return;
      const latestSuccessfulModule0 = items.find((item) => {
        const moduleName = (item.module || "").toLowerCase();
        const status = (item.status_lower || "").toLowerCase();
        return moduleName === updateNetworkFrequenciesModule && status === "success" && item.finished_at;
      });
      if (!latestSuccessfulModule0) return;
      const marker = `${latestSuccessfulModule0.id}:${latestSuccessfulModule0.finished_at}`;
      if (marker === lastAppliedNetworkFrequenciesRunMarker) return;
      lastAppliedNetworkFrequenciesRunMarker = marker;
      refreshNetworkFrequenciesFromConfig();
    }

    function applyConfigValues(config) {
      const general = normalizeConfig(config);
      const moduleValue = moduleSelect.value;
      const inputMappings = {
        "update-network-frequencies": general.last_input || "",
        "configuration-audit": general.last_input_audit || general.last_input || "",
        "consistency-check-bulk": general.last_input_cc_bulk || general.last_input || "",
        "final-cleanup": general.last_input_final_cleanup || general.last_input || ""
      };

      if (moduleValue === "consistency-check") {
        inputFields.input_pre.value = general.last_input_cc_pre || "";
        inputFields.input_post.value = general.last_input_cc_post || "";
      } else {
        inputFields.input.value = inputMappings[moduleValue] || "";
      }

      inputFields.n77_ssb_pre.value = general.n77_ssb_pre || inputFields.n77_ssb_pre.value;
      inputFields.n77_ssb_post.value = general.n77_ssb_post || inputFields.n77_ssb_post.value;
      inputFields.n77b_ssb.value = general.n77b_ssb || inputFields.n77b_ssb.value;
      inputFields.allowed_n77_ssb_pre.value = general.allowed_n77_ssb_pre || inputFields.allowed_n77_ssb_pre.value;
      inputFields.allowed_n77_arfcn_pre.value = general.allowed_n77_arfcn_pre || inputFields.allowed_n77_arfcn_pre.value;
      inputFields.allowed_n77_ssb_post.value = general.allowed_n77_ssb_post || inputFields.allowed_n77_ssb_post.value;
      inputFields.allowed_n77_arfcn_post.value = general.allowed_n77_arfcn_post || inputFields.allowed_n77_arfcn_post.value;
      inputFields.ca_freq_filters.value = general.ca_freq_filters || inputFields.ca_freq_filters.value;
      inputFields.cc_freq_filters.value = general.cc_freq_filters || inputFields.cc_freq_filters.value;
      inputFields.profiles_audit.checked = toBool(general.profiles_audit);
      inputFields.frequency_audit.checked = toBool(general.frequency_audit);
      inputFields.export_correction_cmd.checked = toBool(general.export_correction_cmd);
      inputFields.fast_excel_export.checked = toBool(general.fast_excel_export);
      if (general.network_frequencies) updateNetworkFrequencies(parseCsv(general.network_frequencies));
    }

    function escapeHtml(text) {
      return String(text || "").replace(/[&<>"']/g, (char) => ({
        "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"
      }[char]));
    }

    function parseIni(content) {
      const result = {};
      let currentSection = "";
      content.split(/\r?\n/).forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith(";") || trimmed.startsWith("#")) return;
        const sectionMatch = trimmed.match(/^\[(.+)\]$/);
        if (sectionMatch) { currentSection = sectionMatch[1].trim(); return; }
        const equalsIndex = trimmed.indexOf("=");
        if (equalsIndex === -1) return;
        const key = trimmed.slice(0, equalsIndex).trim();
        const value = trimmed.slice(equalsIndex + 1).trim();
        if (!result[currentSection]) result[currentSection] = {};
        result[currentSection][key] = value;
      });
      return result;
    }

    function parseCsv(value) {
      return String(value || "").split(",").map((item) => item.trim()).filter((item) => item);
    }

    function formatCsv(values) {
      const unique = Array.from(new Set(values));
      unique.sort((a, b) => {
        const aNum = Number(a);
        const bNum = Number(b);
        if (!Number.isNaN(aNum) && !Number.isNaN(bNum)) return aNum - bNum;
        return String(a).localeCompare(String(b));
      });
      return unique.join(",");
    }

    function getSelectedFrequencies() {
      return Array.from(freqList.selectedOptions).map((option) => option.value);
    }

    function updateNetworkFrequencies(values) {
      if (!values || values.length === 0) return;
      freqList.innerHTML = "";
      values.forEach((value) => {
        const option = document.createElement("option");
        option.value = value;
        option.textContent = value;
        freqList.appendChild(option);
      });
      networkFrequenciesField.value = formatCsv(values);
    }

    function addToFilters(targetInput) {
      const selected = getSelectedFrequencies();
      if (selected.length === 0) return;
      const current = parseCsv(targetInput.value);
      targetInput.value = formatCsv([...current, ...selected]);
      scheduleAutoSave();
    }

    function removeFromFilters(targetInput) {
      const selected = new Set(getSelectedFrequencies());
      if (selected.size === 0) return;
      const current = parseCsv(targetInput.value).filter((value) => !selected.has(value));
      targetInput.value = current.join(",");
      scheduleAutoSave();
    }

    function clearFilters(targetInput) {
      targetInput.value = "";
      scheduleAutoSave();
    }

    function selectAllFrequencies() {
      Array.from(freqList.options).forEach((option) => { option.selected = true; });
    }

    function renderLog(text) {
      if (!text) { logOutput.textContent = "No logs yet."; return; }
      const lines = String(text).split(/\r?\n/);
      logOutput.innerHTML = lines.map((line) => {
        let cls = "log-info";
        if (line.includes("[ERROR]")) cls = "log-error";
        else if (line.includes("[WARNING]")) cls = "log-warning";
        else if (line.includes("[DEBUG]")) cls = "log-debug";
        return `<span class="${cls}">${escapeHtml(line)}</span>`;
      }).join("\n");
      if (executionLogAuto?.checked) logOutput.scrollTop = logOutput.scrollHeight;
    }

    function buildNoCacheUrl(baseUrl) {
      const separator = baseUrl.includes("?") ? "&" : "?";
      return `${baseUrl}${separator}_=${Date.now()}_${Math.random().toString(36).slice(2)}`;
    }

    function fetchJsonWithTimeout(url, timeoutMs = 2500) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      return fetch(url, { cache: "no-store", signal: controller.signal })
        .then((res) => res.json())
        .finally(() => clearTimeout(timer));
    }

    function fetchLogByRun() {
      const runId = logRunSelector?.value;
      if (!runId) return fetchJsonWithTimeout(buildNoCacheUrl("/logs/latest")).then((data) => renderLog(data.log || "")).catch(() => renderLog(""));
      fetchJsonWithTimeout(buildNoCacheUrl(`/logs/by_run/${runId}`))
        .then((data) => renderLog(data.log || ""))
        .catch(() => renderLog(""));
    }

    function sortByExecutionOrder(a, b) {
      return Number(a.id) - Number(b.id);
    }

    function pickExecutionLogRunId(items, currentRunId) {
      const currentItem = items.find((item) => String(item.id) === String(currentRunId || ""));
      const runningItems = items.filter((item) => item.status_lower === "running").slice().sort(sortByExecutionOrder);
      const cancelingItems = items.filter((item) => item.status_lower === "canceling").slice().sort(sortByExecutionOrder);
      const queuedItems = items.filter((item) => item.status_lower === "queued").slice().sort(sortByExecutionOrder);

      if (currentItem) {
        const currentStatus = String(currentItem.status_lower || "").toLowerCase();
        if (["running", "canceling"].includes(currentStatus)) return String(currentItem.id);
      }
      if (runningItems.length > 0) return String(runningItems[0].id);
      if (cancelingItems.length > 0) return String(cancelingItems[0].id);
      if (queuedItems.length > 0) return String(queuedItems[0].id);
      if (currentItem) return String(currentItem.id);
      return items[0] ? String(items[0].id) : "";
    }

    function parseRunDateTime(rawValue) {
      const value = (rawValue || "").trim();
      if (!value) return null;
      const normalized = value.replace(/^(\d{4})-(\d{2})-(\d{2})-(\d{2}:\d{2}:\d{2})$/, "$1-$2-$3T$4");
      const timestamp = Date.parse(normalized);
      if (Number.isNaN(timestamp)) return null;
      return new Date(timestamp);
    }

    function buildRunStatusSummary(items) {
      const normalizedItems = Array.isArray(items) ? items : [];
      const hasRunningOrQueued = normalizedItems.some((item) => ["running", "queued", "canceling"].includes(item.status_lower));
      if (hasRunningOrQueued) {
        return {
          latestStatus: "active",
          className: "run-status status-running",
          text: "Tasks Running/Queued...",
          hidden: false
        };
      }

      const now = Date.now();
      const lookbackMs = 24 * 60 * 60 * 1000;
      const recentFinished = normalizedItems.filter((item) => {
        const status = (item.status_lower || "").toLowerCase();
        if (!["success", "error", "ok"].includes(status)) return false;
        const finishedAt = parseRunDateTime(item.finished_at || item.finished_at_raw || "");
        if (!finishedAt) return false;
        return (now - finishedAt.getTime()) <= lookbackMs;
      });

      if (recentFinished.length === 0) {
        return { latestStatus: "", className: "run-status hidden", text: "", hidden: true };
      }

      const hasRecentError = recentFinished.some((item) => {
        const status = (item.status_lower || "").toLowerCase();
        return status === "error";
      });

      return hasRecentError
        ? {
            latestStatus: "error",
            className: "run-status status-error",
            text: "Last 24h: Some tasks with Error!",
            hidden: false
          }
        : {
            latestStatus: "success",
            className: "run-status status-done",
            text: "Last 24h: All Tasks Executed Successfully!",
            hidden: false
          };
    }

    function applyRunStatusSummary(items) {
      if (!runStatusLabel) return;
      const summary = buildRunStatusSummary(items);
      runStatusLabel.dataset.latestStatus = summary.latestStatus;
      runStatusLabel.textContent = summary.text;
      runStatusLabel.className = summary.className;
      runStatusLabel.classList.toggle("hidden", Boolean(summary.hidden));
    }

    function refreshRunsTable(options = {}) {
      const opts = {
        updateExecutionLogPanel: true,
        ...options
      };
      if (runsRefreshInFlight) return runsRefreshPromise || Promise.resolve();
      runsRefreshInFlight = true;

      runsRefreshPromise = fetchJsonWithTimeout(buildNoCacheUrl("/runs/list"), 2500)
        .then((data) => {
          if (!data.ok) return;

          const tbody = document.querySelector("#runs_panel_table tbody");
          if (!tbody) return;

          let activeTasksFound = false;

          const selectedIds = new Set(Array.from(document.querySelectorAll(".run-checkbox:checked")).map((box) => Number(box.value)));
          if (!data.items || data.items.length === 0) {
            tbody.innerHTML = '<tr><td colspan="12">No executions yet.</td></tr>';
            hasActiveTasks = false;
            applyRunStatusSummary([]);
            applyCurrentOrDefaultSort("#runs_panel_table table");
            populateRunScopeSelector();
            updateSelectionSizeLabels();
            return { hasActiveTasks: false };
          }

          tbody.innerHTML = data.items.map((item) => {
            const rowClass = item.status_lower === "error"
              ? "run-row run-error"
              : (item.status_lower === "success"
                ? "run-row run-success"
                : (item.status_lower === "canceled" ? "run-row run-canceled" : "run-row"));

            const checked = selectedIds.has(item.id) ? 'checked' : '';
            const outputCell = item.output_zip ? `<a href="/runs/${item.id}/download">Download zip</a>` : "‚Äî";
            const logCell = item.output_log_file ? `<a href="/runs/${item.id}/log">Download log</a>` : "‚Äî";

            return `
              <tr class="${rowClass}" data-run-id="${item.id}" data-status="${item.status_lower}" data-run-user="${escapeHtml(currentUsername)}">
                <td><input type="checkbox" class="run-checkbox" value="${item.id}" data-start="${item.started_at}" data-status="${item.status_lower}" ${checked} /></td>
                <td>${escapeHtml(item.id)}</td>
                <td>${escapeHtml(item.module)}</td>
                <td>${escapeHtml(item.tool_version || "‚Äî")}</td>
                <td>${escapeHtml(item.input_name || "‚Äî")}</td>
                <td class="run-status-cell">${escapeHtml(item.status_display)}</td>
                <td class="run-start-cell">${escapeHtml(item.started_at || "")}</td>
                <td class="run-finished-cell">${escapeHtml(item.finished_at || "")}</td>
                <td class="run-duration-cell">${escapeHtml(item.duration_hms || "00:00:00")}</td>
                <td class="run-output-cell">${outputCell}</td>
                <td class="run-log-cell">${logCell}</td>
                <td>${escapeHtml(item.size_mb || "0.00 MB")}</td>
              </tr>`;
          }).join("");

          if (logRunSelector && opts.updateExecutionLogPanel) {
            const nextRunId = pickExecutionLogRunId(data.items, logRunSelector.value);
            logRunSelector.innerHTML = data.items.map((item) => `<option value="${item.id}">${escapeHtml(item.run_label)}</option>`).join("");
            if (nextRunId) logRunSelector.value = nextRunId;
            fetchLogByRun();
          }

          const hasRunning = data.items.some((item) => item.status_lower === "running" || item.status_lower === "canceling");
          const hasQueued = data.items.some((item) => item.status_lower === "queued");
          activeTasksFound = hasRunning || hasQueued;
          hasActiveTasks = activeTasksFound;
          applyRunStatusSummary(data.items);
          syncNetworkFrequenciesAfterModule0Run(data.items);

          applyCurrentOrDefaultSort("#runs_panel_table table");
          populateRunScopeSelector();
          applyScopeFilter("#runs_panel_table", (row) => row?.dataset?.runUser || currentUsername, selectUserRunsCombo?.value);
          updateExecutionAutoRefreshAvailability(activeTasksFound);
          updateSelectionSizeLabels();
          return { hasActiveTasks: activeTasksFound };
        })
        .catch(() => ({ hasActiveTasks }))
        .finally(() => {
          runsRefreshInFlight = false;
          runsRefreshPromise = null;
        });

      return runsRefreshPromise;
    }

    function renderSystemLog(text) {
      if (!text) {
        systemLogOutput.textContent = "No logs yet.";
        if (systemLogAuto?.checked) systemLogOutput.scrollTop = systemLogOutput.scrollHeight;
        return;
      }
      const lines = String(text).split(/\r?\n/);
      systemLogOutput.innerHTML = lines.map((line) => {
        let cls = "log-info";
        if (line.includes("[ERROR]")) cls = "log-error";
        else if (line.includes("[WARNING]")) cls = "log-warning";
        else if (line.includes("[DEBUG]")) cls = "log-debug";
        return `<span class="${cls}">${escapeHtml(line)}</span>`;
      }).join("\n");
      if (systemLogAuto?.checked) systemLogOutput.scrollTop = systemLogOutput.scrollHeight;
    }

    function fetchSystemLog() {
      const source = systemLogSource?.value || "app";
      fetch(buildNoCacheUrl(`/logs/system?source=${encodeURIComponent(source)}`), { cache: "no-store" })
        .then((res) => res.json())
        .then((data) => renderSystemLog(data.log || ""))
        .catch(() => renderSystemLog(""));
    }

    function collectFormValues() {
      const form = document.querySelector(".module-form");
      const data = new FormData(form);
      const payload = {};
      data.forEach((value, key) => { payload[key] = value; });
      ["profiles_audit", "frequency_audit", "export_correction_cmd", "fast_excel_export"].forEach((key) => {
        payload[key] = form.querySelector(`input[name="${key}"]`).checked;
      });
      return payload;
    }

    let saveTimeout = null;
    function scheduleAutoSave() {
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        fetch("/settings/update", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(collectFormValues())
        }).catch(() => {});
      }, 400);
    }

    document.querySelectorAll(".module-form input, .module-form select").forEach((field) => {
      field.addEventListener("change", scheduleAutoSave);
      field.addEventListener("input", scheduleAutoSave);
    });

    loadConfigButton.addEventListener("click", () => configPicker.click());

    configPicker.addEventListener("change", () => {
      const file = configPicker.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const parsed = parseIni(reader.result || "");
        applyConfigValues(parsed);
        scheduleAutoSave();
      };
      reader.readAsText(file);
    });

    exportConfigButton.addEventListener("click", () => { window.location.href = "/config/export"; });

    changePasswordButton.addEventListener("click", async () => {
      const response = await showModal({
        title: "Change password",
        message: "Enter a new password:",
        confirmText: "Accept",
        cancelText: "Cancel",
        showInput: true,
        inputPlaceholder: "New password"
      });
      const newPassword = (response.value || "").trim();
      if (!response.ok || !newPassword) return;

      fetch("/account/change_password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ new_password: newPassword })
      }).then(async (res) => {
        if (res.ok) {
          await showModal({ title: "Password updated", message: "Password updated. Please sign in again.", confirmText: "Accept" });
          window.location.href = "/login";
        }
      });
    });

    function copyToClipboard(text) {
      if (!text) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).catch(() => {});
        return;
      }
      const helper = document.createElement("textarea");
      helper.value = text;
      document.body.appendChild(helper);
      helper.select();
      document.execCommand("copy");
      document.body.removeChild(helper);
    }

    copyLogButton.addEventListener("click", () => copyToClipboard(logOutput.textContent || ""));
    copySelectionButton.addEventListener("click", () => {
      const selection = window.getSelection();
      if (selection) copyToClipboard(selection.toString());
    });

    refreshSystemLogButton?.addEventListener("click", fetchSystemLog);
    copySystemLogButton?.addEventListener("click", () => copyToClipboard(systemLogOutput.textContent || ""));
    copySystemSelectionButton?.addEventListener("click", () => {
      const selection = window.getSelection();
      if (selection) copyToClipboard(selection.toString());
    });
    systemLogSource?.addEventListener("change", () => {
      fetchSystemLog();
    });

    function getTargetFiltersInput() {
      return freqTargetSelect.value === "cc" ? ccFiltersInput : caFiltersInput;
    }
    freqAddButton.addEventListener("click", () => addToFilters(getTargetFiltersInput()));
    freqRemoveButton.addEventListener("click", () => removeFromFilters(getTargetFiltersInput()));
    freqClearButton.addEventListener("click", () => clearFilters(getTargetFiltersInput()));
    selectAllButton.addEventListener("click", selectAllFrequencies);

    function getSelectedRunIds() {
      return Array.from(document.querySelectorAll(".run-checkbox:checked")).map((box) => Number(box.value));
    }

    function selectErrorRuns() {
      const table = document.querySelector(".latest-runs-scroll table");
      const headerCells = table ? table.querySelectorAll("thead th") : [];
      let statusIndex = -1;
      headerCells.forEach((cell, index) => {
        if (cell.textContent.trim().toLowerCase() === "status") statusIndex = index;
      });

      document.querySelectorAll(".run-checkbox").forEach((box) => {
        const row = box.closest("tr");
        const statusColumn = row && statusIndex >= 0 ? row.cells[statusIndex] : null;
        const statusText = statusColumn ? statusColumn.textContent.trim().toLowerCase() : "";
        const statusAttr = (row?.dataset.status || box.dataset.status || "").trim().toLowerCase();
        if (statusText === "error" || statusAttr === "error" || row?.classList.contains("run-error")) box.checked = true;
      });
    }
    selectErrorRunsButton?.addEventListener("click", selectErrorRuns);

    function selectRunsByStatuses(statuses) {
      const normalizedStatuses = (statuses || []).map((status) => String(status).toLowerCase());
      document.querySelectorAll(".run-checkbox").forEach((box) => {
        const row = box.closest("tr");
        if (row?.classList.contains("hidden")) return;
        const statusAttr = (row?.dataset.status || box.dataset.status || "").trim().toLowerCase();
        if (normalizedStatuses.includes(statusAttr)) box.checked = true;
      });
      updateSelectionSizeLabels();
    }

    selectRunningQueuedRunsButton?.addEventListener("click", () => {
      selectRunsByStatuses(["running", "queued"]);
    });

    selectCancelledRunsButton?.addEventListener("click", () => {
      selectRunsByStatuses(["canceled"]);
    });

    let lastChecked = null;
    document.querySelectorAll(".run-checkbox").forEach((box) => {
      box.addEventListener("click", (event) => {
        if (!event.shiftKey || !lastChecked) { lastChecked = box; return; }
        const checkboxes = Array.from(document.querySelectorAll(".run-checkbox"));
        const start = checkboxes.indexOf(box);
        const end = checkboxes.indexOf(lastChecked);
        const [min, max] = start < end ? [start, end] : [end, start];
        for (let i = min; i <= max; i += 1) checkboxes[i].checked = lastChecked.checked;
      });
    });

    selectOlderRunsButton?.addEventListener("click", () => {
      const picker = document.getElementById("older_date_picker");
      picker?.showPicker();
    });

    selectUserRunsCombo?.addEventListener("change", () => {
      applyScopeFilter("#runs_panel_table", (row) => row?.dataset?.runUser || currentUsername, selectUserRunsCombo.value);
      updateSelectionSizeLabels();
    });

    selectAllRunsButton?.addEventListener("click", () => {
      toggleVisibleCheckboxes("#runs_panel_table", ".run-checkbox", true);
    });

    selectNoneRunsButton?.addEventListener("click", () => {
      toggleVisibleCheckboxes("#runs_panel_table", ".run-checkbox", false);
    });

    const olderDatePicker = document.getElementById("older_date_picker");
    olderDatePicker?.addEventListener("change", () => {
      const selected = olderDatePicker.value;
      if (!selected) return;
      const threshold = new Date(`${selected}T00:00:00`);
      if (Number.isNaN(threshold.getTime())) return;

      document.querySelectorAll(".run-checkbox").forEach((box) => {
        const startValue = box.dataset.start;
        if (!startValue) return;
        const parts = startValue.split("-");
        const normalized = `${parts[0]}-${parts[1]}-${parts[2]}T${parts[3] || "00:00:00"}`;
        const startDate = new Date(normalized);
        if (!Number.isNaN(startDate.getTime()) && startDate < threshold) box.checked = true;
      });
      olderDatePicker.value = "";
      updateSelectionSizeLabels();
    });

    stopSelectedRunsButton?.addEventListener("click", async () => {
      const ids = getSelectedRunIds();
      if (!ids.length) return;
      const stopRunsAnswer = await showModal({ title: "Stop executions", message: "Stop selected queued/running tasks?", confirmText: "Accept", cancelText: "Cancel" });
      if (!stopRunsAnswer.ok) return;

      ids.forEach((id) => {
        const row = document.querySelector(`#runs_panel_table tr[data-run-id="${id}"]`);
        const statusCell = row?.querySelector(".run-status-cell");
        if (statusCell) statusCell.textContent = "Canceling";
      });

      fetch(buildNoCacheUrl("/runs/stop"), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ids }),
        cache: "no-store"
      })
        .then(() => {
          let attempts = 0;
          const maxAttempts = 20;
          const pollStopStatus = () => {
            attempts += 1;
            return refreshRunsTable().then(() => {
              const stillCanceling = ids.some((id) => {
                const row = document.querySelector(`#runs_panel_table tr[data-run-id="${id}"]`);
                if (!row) return false;
                const status = String(row.getAttribute("data-status") || "").toLowerCase();
                return status === "running" || status === "canceling";
              });
              if (!stillCanceling || attempts >= maxAttempts) return;
              return new Promise((resolve) => setTimeout(resolve, 1000)).then(pollStopStatus);
            });
          };
          return pollStopStatus();
        })
        .catch(() => {});
    });

    deleteSelectedRunsButton?.addEventListener("click", async () => {
      const ids = getSelectedRunIds();
      if (!ids.length) return;
      const removeRunsAnswer = await showModal({
        title: "Delete executions",
        message: "This will delete the Uploads and Exports for the selected executions. Continue?",
        confirmText: "Accept",
        cancelText: "Cancel"
      });
      if (!removeRunsAnswer.ok) return;
      fetch("/runs/delete", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ids })
      }).then(() => window.location.reload());
    });

    function buildSessionId() {
      const now = new Date();
      const pad = (value) => String(value).padStart(2, "0");
      return now.getFullYear().toString() + pad(now.getMonth() + 1) + pad(now.getDate()) + "_" + pad(now.getHours()) + pad(now.getMinutes()) + pad(now.getSeconds());
    }

    let uploadSessionId = buildSessionId();

    function getSelectedInputIds() {
      return Array.from(document.querySelectorAll(".input-checkbox:checked")).map((box) => Number(box.value));
    }

    selectOlderInputsButton?.addEventListener("click", () => olderInputDatePicker?.showPicker());

    selectUserInputsCombo?.addEventListener("change", () => {
      applyScopeFilter("#inputs_panel_table", (row) => row?.cells?.[2]?.textContent?.trim() || "", selectUserInputsCombo.value);
      updateSelectionSizeLabels();
    });

    selectAllInputsButton?.addEventListener("click", () => {
      toggleVisibleCheckboxes("#inputs_panel_table", ".input-checkbox", true);
    });

    selectNoneInputsButton?.addEventListener("click", () => {
      toggleVisibleCheckboxes("#inputs_panel_table", ".input-checkbox", false);
    });

    olderInputDatePicker?.addEventListener("change", () => {
      const selected = olderInputDatePicker.value;
      if (!selected) return;
      const threshold = new Date(`${selected}T00:00:00`);
      document.querySelectorAll(".input-checkbox").forEach((box) => {
        const raw = box.dataset.uploadedAt || "";
        const normalized = raw.replace(/-/g,":");
        const d = new Date(normalized);
        if (!Number.isNaN(d.getTime()) && d < threshold) box.checked = true;
      });
      olderInputDatePicker.value = "";
      updateSelectionSizeLabels();
    });

    sendSelectedInputsButton?.addEventListener("click", async () => {
      const selectedByTarget = collectSelectedInputsByTarget();
      const totalSelected = selectedByTarget.single.length + selectedByTarget.pre.length + selectedByTarget.post.length;
      if (!totalSelected) {
        await showModal({ title: "Selection required", message: "Select at least one input in Inputs Repository panel.", confirmText: "Accept" });
        return;
      }

      const isConsistencyCheck = moduleSelect.value === "consistency-check";
      if (isConsistencyCheck) {
        if (selectedByTarget.single.length > 0 || (selectedByTarget.pre.length === 0 && selectedByTarget.post.length === 0)) {
          await showModal({
            title: "‚ùå Invalid target selection",
            message: "Module 2 expects Input PRE and/or Input POST targets only. Please set target column values to Input PRE or Input POST and try again.",
            confirmText: "Accept",
            tone: "error"
          });
          return;
        }
      } else if (selectedByTarget.pre.length > 0 || selectedByTarget.post.length > 0) {
        await showModal({
          title: "‚ùå Invalid target selection",
          message: "This module expects Single Input targets only. Please set all selected target values to Single Input and try again.",
          confirmText: "Accept",
          tone: "error"
        });
        return;
      }

      if (selectedByTarget.single.length) inputFields.input.value = selectedByTarget.single.join(",");
      if (selectedByTarget.pre.length) inputFields.input_pre.value = selectedByTarget.pre.join(",");
      if (selectedByTarget.post.length) inputFields.input_post.value = selectedByTarget.post.join(",");

      scheduleAutoSave();
      await showModal({ title: "Inputs assigned", message: "Selected inputs were sent to Input / Input PRE / Input POST based on each row target.", confirmText: "Accept" });
    });

    deleteSelectedInputsButton?.addEventListener("click", async () => {
      const ids = getSelectedInputIds();
      if (!ids.length) return;
      const removeInputsAnswer = await showModal({ title: "Delete inputs", message: "Delete selected inputs?", confirmText: "Accept", cancelText: "Cancel" });
      if (!removeInputsAnswer.ok) return;

      fetch("/inputs/delete", {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({ids})
      })
        .then((res) => res.json())
        .then(async (data) => {
          if (!data.ok && data.error === "forbidden_inputs") {
            await showModal({ title: "Action not allowed", message: "Only inputs uploaded by your user can be deleted. Admin users can delete any input only from the Admin panel.", confirmText: "Accept" });
          }
          return refreshInputsRepository();
        });
    });

    toggleRunsPanelButton?.addEventListener("click", () => {
      runsPanelTable?.classList.toggle("hidden");
      toggleRunsPanelButton.textContent = runsPanelTable?.classList.contains("hidden") ? "‚ñ∏" : "‚ñæ";
    });

    toggleExecutionLogPanelButton?.addEventListener("click", () => {
      logOutput?.classList.toggle("hidden");
      toggleExecutionLogPanelButton.textContent = logOutput?.classList.contains("hidden") ? "‚ñ∏" : "‚ñæ";
    });

    toggleSystemLogPanelButton?.addEventListener("click", () => {
      systemLogOutput?.classList.toggle("hidden");
      toggleSystemLogPanelButton.textContent = systemLogOutput?.classList.contains("hidden") ? "‚ñ∏" : "‚ñæ";
    });

    toggleInputsPanelButton?.addEventListener("click", () => {
      inputsPanelTable?.classList.toggle("hidden");
      toggleInputsPanelButton.textContent = inputsPanelTable?.classList.contains("hidden") ? "‚ñ∏" : "‚ñæ";
    });

    moduleSelect.addEventListener("change", () => {
      toggleInputRows();
      updateModuleAvailability();
    });
    toggleInputRows();
    updateModuleAvailability();

    const moduleForm = document.querySelector(".module-form");
    moduleForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      if (isModuleBlocked()) { updateModuleAvailability(); return; }

      logOutput.textContent = "";
      uploadSessionId = buildSessionId();

      const isConsistencyCheck = moduleSelect.value === "consistency-check";
      const singleInputs = parseCsvList(inputFields.input.value);
      const preInputs = parseCsvList(inputFields.input_pre.value);
      const postInputs = parseCsvList(inputFields.input_post.value);

      selectedInputsSingleField.value = "";
      selectedInputsPreField.value = "";
      selectedInputsPostField.value = "";

      let confirmationMessage = "";
      let confirmationHtml = "";

      if (!isConsistencyCheck && singleInputs.length > 1) {
        selectedInputsSingleField.value = singleInputs.join("|");
        inputFields.input.value = singleInputs[0];
        confirmationMessage = `You selected ${singleInputs.length} inputs. Queue one task per input?`;
        confirmationHtml = `${escapeHtml(confirmationMessage)}${buildBatchListHtml(singleInputs)}`;
      } else if (isConsistencyCheck && (preInputs.length > 1 || postInputs.length > 1)) {
        const isPairable = preInputs.length === postInputs.length || preInputs.length === 1 || postInputs.length === 1;
        if (!isPairable) {
          showModal({ title: "Invalid PRE/POST pairing", message: "Cannot queue tasks: PRE and POST selections have different lengths and both are greater than 1.", confirmText: "Accept" });
          return;
        }
        selectedInputsPreField.value = preInputs.join("|");
        selectedInputsPostField.value = postInputs.join("|");
        inputFields.input_pre.value = preInputs[0] || "";
        inputFields.input_post.value = postInputs[0] || "";

        const queuedCount = Math.max(preInputs.length, postInputs.length);
        const pairingList = Array.from({ length: queuedCount }).map((_, idx) => {
          const preValue = preInputs.length > 1 ? preInputs[idx] : (preInputs[0] || "");
          const postValue = postInputs.length > 1 ? postInputs[idx] : (postInputs[0] || "");
          return `PRE: ${preValue} | POST: ${postValue}`;
        });
        confirmationMessage = `You selected multiple PRE/POST inputs. Queue ${queuedCount} task(s) using those pairings?`;
        confirmationHtml = `${escapeHtml(confirmationMessage)}${buildBatchListHtml(pairingList)}`;
      }

      const currentInput = isConsistencyCheck ? (document.getElementById("input_post_path")?.value || "") : (document.getElementById("input_path")?.value || "");
      const taskName = currentInput.split("/").filter(Boolean).pop() || "unknown";
      const confirmText = confirmationMessage || `Queue task: ${taskName}?`;

      const queueAnswer = await showModal({ title: "Queue task", message: confirmText, messageHtml: confirmationHtml, confirmText: "Accept", cancelText: "Cancel" });
      if (!queueAnswer.ok) return;

      runStatusLabel.textContent = "Tasks Running/Queued...";
      runStatusLabel.className = "run-status status-running";
      runStatusLabel.classList.remove("hidden");
      markExecutionAutoEnablePending();
      setExecutionAutoChecked(true);
      runModuleButton.disabled = true;
      moduleForm.submit();
    });

    if (runStatusLabel) {
      runStatusLabel.classList.add("hidden");
      runStatusLabel.dataset.latestStatus = "";
      runStatusLabel.textContent = "";
    }

    initSortableTable("#inputs_panel_table table");
    initSortableTable("#runs_panel_table table");

    fetch("/config/load")
      .then((res) => res.json())
      .then((data) => applyConfigValues(data))
      .catch(() => {});

    function manualRefreshExecutionLogPanel() {
      refreshRunsTable({ updateExecutionLogPanel: true });
    }

    logRunSelector?.addEventListener("change", fetchLogByRun);
    refreshLogButton?.addEventListener("click", manualRefreshExecutionLogPanel);
    fetchLogByRun();
    fetchSystemLog();
    scheduleSystemLogRefresh();
    refreshInputsRepository();
    refreshRunsTable({ updateExecutionLogPanel: false }).finally(() => {
      scheduleBackgroundRefresh();
    });
    populateInputScopeSelector();
    populateRunScopeSelector();

    if (inputsTotalSizeLabel) inputsTotalSizeLabel.dataset.totalSize = "{{ inputs_total_size }}";
    if (runsTotalSizeLabel) runsTotalSizeLabel.dataset.totalSize = "{{ total_runs_size }}";

    applyScopeFilter("#inputs_panel_table", (row) => row?.cells?.[2]?.textContent?.trim() || "", selectUserInputsCombo?.value);
    applyScopeFilter("#runs_panel_table", (row) => row?.dataset?.runUser || currentUsername, selectUserRunsCombo?.value);

    document.addEventListener("change", (event) => {
      const target = event.target;
      if (target && (target.classList?.contains("input-checkbox") || target.classList?.contains("run-checkbox"))) updateSelectionSizeLabels();
    });
    updateSelectionSizeLabels();

    const clearBackgroundRefreshTimer = () => {
      if (backgroundRefreshTimer) {
        clearTimeout(backgroundRefreshTimer);
        backgroundRefreshTimer = null;
      }
    };

    const clearSystemLogRefreshTimer = () => {
      if (systemLogRefreshTimer) {
        clearInterval(systemLogRefreshTimer);
        systemLogRefreshTimer = null;
      }
    };

    const scheduleSystemLogRefresh = () => {
      clearSystemLogRefreshTimer();
      if (!systemLogAuto?.checked) return;
      systemLogRefreshTimer = setInterval(() => {
        fetchSystemLog();
      }, 60000);
    };

    const shouldPollBackground = () => {
      return Boolean(executionLogAuto?.checked || hasActiveTasks);
    };

    const scheduleBackgroundRefresh = () => {
      clearBackgroundRefreshTimer();
      if (!shouldPollBackground()) return;
      backgroundRefreshTimer = setTimeout(runBackgroundRefreshCycle, 3000);
    };

    function runBackgroundRefreshCycle() {
      const updateExecutionLogPanel = Boolean(executionLogAuto?.checked);
      refreshRunsTable({ updateExecutionLogPanel })
        .finally(scheduleBackgroundRefresh);
    }

    function updateExecutionAutoRefreshAvailability(hasActive) {
      if (!executionLogAuto) return;
      executionLogAuto.disabled = !hasActive;

      if (!hasActive) {
        setExecutionAutoChecked(false);
        clearExecutionAutoEnablePending();
        scheduleBackgroundRefresh();
        return;
      }

      if (pendingExecutionAutoEnable && !executionLogAuto.checked) {
        setExecutionAutoChecked(true);
        fetchLogByRun();
      }
      clearExecutionAutoEnablePending();
      persistExecutionAutoCheckedState(executionLogAuto.checked);
      scheduleBackgroundRefresh();
    }

    executionLogAuto?.addEventListener("change", () => {
      persistExecutionAutoCheckedState(executionLogAuto.checked);
      if (executionLogAuto.checked) fetchLogByRun();
      scheduleBackgroundRefresh();
    });

    systemLogAuto?.addEventListener("change", () => {
      if (systemLogAuto.checked) fetchSystemLog();
      scheduleSystemLogRefresh();
      scheduleBackgroundRefresh();
    });

  </script>
</body>
</html>
