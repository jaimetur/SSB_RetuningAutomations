<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSB Retuning Automations - Web Interface</title>
  <link rel="stylesheet" href="/static/styles.css" />
</head>
<body>
  <!-- Main dashboard -->
  <main class="container">
    <header class="topbar">
      <div>
        <h1>SSB Retuning Automations - Web Interface</h1>
      </div>
      <nav>
        <div class="user-meta">User: <b>{{ user.username }}</b> ({{ user.role }})</div>
        <div class="nav-links">
          {% if user.role == 'admin' %}<a href="/admin">Admin panel</a>{% endif %}
          <a href="/logout">Sign out</a>
        </div>
      </nav>
    </header>

    <section class="card module-card">
      <div class="module-meta">v{{ tool_meta.version }} - {{ tool_meta.date }}</div>
      <div class="module-header">
        <img class="module-logo" src="/static/logo_02.png" alt="SSB Retuning Automations logo" />
        <div class="module-title">
          <h2>SSB Retuning Automations</h2>
          <p class="module-eyebrow">Web Interface</p>
          <p class="module-subtitle">1️⃣ Select Module. 2️⃣ Configure Paths & Freqs. 3️⃣ Press Run to execute...</p>
        </div>
        <div class="module-actions">
          <button type="button" class="btn btn-danger" id="change_password_button">Change Password</button>
          <div class="btn-row">
            <button type="button" class="browse-button" id="load_config_button">Load config.cfg</button>
            <button type="button" class="browse-button" id="export_config_button">Export config.cfg</button>
          </div>
        </div>
      </div>
      <form action="/run" method="post" class="module-form">
        <div class="form-section">
          <p class="section-title">Module to execute</p>
          <label class="label-wide">
            <select name="module" required>
              {% for value, label in module_options %}
                <option value="{{ value }}" {% if settings.get('module') == value %}selected{% endif %}>{{ label }}</option>
              {% endfor %}
            </select>
          </label>
        </div>

        <div class="form-section">
          <p class="section-title">Inputs</p>
          <div class="grid grid-1" id="single-input-row">
            <label>
              <span class="input-with-button">
                <input type="text" name="input" id="input_path" value="{{ settings.get('input', '') }}" placeholder="/path/input" aria-label="Input" />
                <button type="button" class="browse-button upload-button" data-target="input_path" data-file="input_zip" data-kind="input">Upload/Save Input</button>
              </span>
            </label>
          </div>
          <div class="grid grid-1 hidden" id="prepost-input-rows">
            <label>Input PRE
              <span class="input-with-button">
                <input type="text" name="input_pre" id="input_pre_path" value="{{ settings.get('input_pre', '') }}" />
                <button type="button" class="browse-button upload-button" data-target="input_pre_path" data-file="input_pre_zip" data-kind="input_pre">Upload/Save Input</button>
              </span>
            </label>
            <label>Input POST
              <span class="input-with-button">
                <input type="text" name="input_post" id="input_post_path" value="{{ settings.get('input_post', '') }}" />
                <button type="button" class="browse-button upload-button" data-target="input_post_path" data-file="input_post_zip" data-kind="input_post">Upload/Save Input</button>
              </span>
            </label>
          </div>
          <input type="file" id="input_zip" class="hidden" accept=".zip,.log,.txt" multiple />
          <input type="file" id="input_pre_zip" class="hidden" accept=".zip,.log,.txt" multiple />
          <input type="file" id="input_post_zip" class="hidden" accept=".zip,.log,.txt" multiple />
          <input type="file" id="config_picker" class="hidden" accept=".cfg" />
        </div>

        <div class="form-section">
          <p class="section-title">SSB frequencies</p>
          <div class="grid grid-3">
            <label>N77 SSB PRE
              <input type="text" name="n77_ssb_pre" value="{{ settings.get('n77_ssb_pre', '') }}" />
            </label>
            <label>N77 SSB POST
              <input type="text" name="n77_ssb_post" value="{{ settings.get('n77_ssb_post', '') }}" />
            </label>
            <label>N77B SSB
              <input type="text" name="n77b_ssb" value="{{ settings.get('n77b_ssb', '') }}" />
            </label>
          </div>
        </div>

        <div class="form-section">
          <p class="section-title">Allowed SSB and ARFCN lists (comma-separated values)</p>
          <div class="grid grid-2">
            <label>Allowed N77 SSB PRE
              <input type="text" name="allowed_n77_ssb_pre" value="{{ settings.get('allowed_n77_ssb_pre', '') }}" />
            </label>
            <label>Allowed N77 ARFCN PRE
              <input type="text" name="allowed_n77_arfcn_pre" value="{{ settings.get('allowed_n77_arfcn_pre', '') }}" />
            </label>
            <label>Allowed N77 SSB POST
              <input type="text" name="allowed_n77_ssb_post" value="{{ settings.get('allowed_n77_ssb_post', '') }}" />
            </label>
            <label>Allowed N77 ARFCN POST
              <input type="text" name="allowed_n77_arfcn_post" value="{{ settings.get('allowed_n77_arfcn_post', '') }}" />
            </label>
          </div>
        </div>

        <div class="form-section">
          <p class="section-title">Frequency filters</p>
          <div class="freq-selector">
            <div class="freq-fields">
              <label>Configuration Audit filters (empty = no filter)
                <input type="text" name="ca_freq_filters" id="ca_freq_filters" value="{{ settings.get('ca_freq_filters', '') }}" />
              </label>
              <label>Consistency Checks filters (empty = no filter)
                <input type="text" name="cc_freq_filters" id="cc_freq_filters" value="{{ settings.get('cc_freq_filters', '') }}" />
              </label>
            </div>
            <div class="freq-buttons">
              <div class="freq-group">
                <label>Apply to
                  <select id="freq_target">
                    <option value="ca">Configuration Audit</option>
                    <option value="cc">Consistency Checks</option>
                  </select>
                </label>
                <button type="button" id="freq_add" class="btn btn-primary">← Add</button>
                <button type="button" id="freq_clear" class="btn btn-danger">Clear</button>
                <button type="button" id="freq_remove" class="btn btn-accent">Remove →</button>
              </div>
              <button type="button" id="freq_select_all">Select all in list</button>
            </div>
            <div class="freq-list">
              <label>Network frequencies
                <select id="freq_list" multiple size="10">
                  {% for freq in network_frequencies %}
                    <option value="{{ freq }}">{{ freq }}</option>
                  {% endfor %}
                </select>
              </label>
            </div>
          </div>
          <input type="hidden" name="network_frequencies" id="network_frequencies" value="{{ ','.join(network_frequencies) }}" />
        </div>

        <div class="form-section options-section">
          <p class="section-title">Options</p>
          <div class="grid grid-2">
            <label class="checkbox">
              <input type="checkbox" name="profiles_audit" {% if settings.get('profiles_audit') %}checked{% endif %}>
              Profiles Audit
            </label>
            <label class="checkbox">
              <input type="checkbox" name="frequency_audit" {% if settings.get('frequency_audit') %}checked{% endif %}>
              Frequency Audit
            </label>
            <label class="checkbox">
              <input type="checkbox" name="export_correction_cmd" {% if settings.get('export_correction_cmd') %}checked{% endif %}>
              Export Correction Cmd
            </label>
            <label class="checkbox">
              <input type="checkbox" name="fast_excel_export" {% if settings.get('fast_excel_export') %}checked{% endif %}>
              Fast Excel Export
            </label>
          </div>
        </div>

        <div class="form-actions">
          <button type="submit" class="btn btn-success" id="run_module_button">Run Module</button>
          <span class="module-unavailable hidden" id="module_unavailable_message">This module is not available from the Web Interface.</span>
        </div>
        <input type="hidden" name="selected_inputs_single" id="selected_inputs_single" value="" />
        <input type="hidden" name="selected_inputs_pre" id="selected_inputs_pre" value="" />
        <input type="hidden" name="selected_inputs_post" id="selected_inputs_post" value="" />
      </form>
      <span class="run-status" id="run_status" data-latest-status="{{ latest_runs[0].status_lower if latest_runs else '' }}"></span>
    </section>


    <section class="card">
      <div class="runs-header">
        <h2>Inputs Repository</h2>
        <div class="runs-actions">
          <span class="runs-total" id="inputs_total_size">Total size: {{ inputs_total_size }}</span>
          <button type="button" id="select_all_inputs">Select All</button>
          <button type="button" id="unselect_all_inputs">Un-Select All</button>
          <button type="button" id="select_older_inputs" class="btn btn-accent">Select Older</button>
          <button type="button" id="send_selected_inputs" class="btn btn-success">Send to Input</button>
          <button type="button" id="delete_selected_inputs" class="btn btn-danger">Delete Selected</button>
          <button type="button" id="toggle_inputs_panel" class="panel-toggle" aria-label="Collapse inputs panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <input type="date" id="older_input_date_picker" class="hidden" />
      <div class="table-scroll" id="inputs_panel_table">
      <table>
        <thead><tr><th></th><th class="sortable" data-sort-key="text">Input</th><th class="sortable" data-sort-key="text">Uploaded by</th><th class="sortable" data-sort-key="datetime" data-default-sort="desc">Uploaded at</th><th class="sortable" data-sort-key="size">Size</th><th class="sortable" data-sort-key="text">Target</th></tr></thead>
        <tbody>
        {% for item in input_items %}
          <tr>
            <td><input type="checkbox" class="input-checkbox" value="{{ item.id }}" data-uploaded-at="{{ item.uploaded_at }}" /></td>
            <td>{{ item.input_name }}</td><td>{{ item.uploaded_by }}</td><td>{{ item.uploaded_at }}</td><td>{{ item.size_mb }}</td>
            <td data-input-path="{{ item.input_path }}"><select class="send-target"><option value="single">Single Input</option><option value="pre">Input PRE</option><option value="post">Input POST</option></select></td>
          </tr>
        {% else %}
          <tr><td colspan="6">No inputs in repository.</td></tr>
        {% endfor %}
        </tbody>
      </table>
      </div>
    </section>

    <section class="card">
      <div class="runs-header">
        <h2>Latest Executions</h2>
        <div class="runs-actions">
          <span class="runs-total">Total size: {{ total_runs_size }}</span>
          <button type="button" id="select_all_runs">Select All</button>
          <button type="button" id="unselect_all_runs">Un-Select All</button>
          <button type="button" id="select_older_runs" class="btn btn-accent">Select Older</button>
          <button type="button" id="select_error_runs" class="btn btn-accent">Select Error</button>
          <button type="button" id="stop_selected_runs" class="btn btn-danger">Stop Selected</button>
          <button type="button" id="delete_selected_runs" class="btn btn-danger">Delete Selected</button>
          <button type="button" id="toggle_runs_panel" class="panel-toggle" aria-label="Collapse runs panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <input type="date" id="older_date_picker" class="hidden" />
      <div class="latest-runs-scroll" id="runs_panel_table">
      <table>
        <thead><tr><th></th><th class="sortable" data-sort-key="number">ID</th><th class="sortable" data-sort-key="text">Module</th><th class="sortable" data-sort-key="text">Version</th><th class="sortable" data-sort-key="text">Input</th><th class="sortable" data-sort-key="text">Status</th><th class="sortable" data-sort-key="datetime" data-default-sort="desc">Start</th><th class="sortable" data-sort-key="datetime">End</th><th class="sortable" data-sort-key="duration">Duration</th><th class="sortable" data-sort-key="text">Output</th><th class="sortable" data-sort-key="text">Log</th><th class="sortable" data-sort-key="size">Size</th></tr></thead>
        <tbody>
        {% for r in latest_runs %}
          <tr class="run-row {% if r.status_lower == 'error' %}run-error{% elif r.status_lower == 'success' %}run-success{% elif r.status_lower == 'canceled' %}run-canceled{% endif %}" data-run-id="{{ r.id }}" data-status="{{ r.status_lower }}">
            <td><input type="checkbox" class="run-checkbox" value="{{ r.id }}" data-start="{{ r.started_at }}" data-status="{{ r.status_lower }}" /></td>
            <td>{{ r.id }}</td>
            <td>{{ r.module }}</td>
            <td>{{ r.tool_version or '—' }}</td>
            <td>{{ r.input_name or "—" }}</td>
            <td class="run-status-cell">{{ r.status_display }}</td>
            <td class="run-start-cell">{{ r.started_at }}</td>
            <td class="run-finished-cell">{{ r.finished_at }}</td>
            <td class="run-duration-cell">{{ r.duration_hms }}</td>
            <td class="run-output-cell">
              {% if r.output_zip %}
                <a href="/runs/{{ r.id }}/download">Download zip</a>
              {% else %}
                —
              {% endif %}
            </td>
            <td class="run-log-cell">
              {% if r.output_log_file %}
                <a href="/runs/{{ r.id }}/log">Download log</a>
              {% else %}
                —
              {% endif %}
            </td>
            <td>{{ r.size_mb }}</td>
          </tr>
        {% else %}
          <tr><td colspan="12">No executions yet.</td></tr>
        {% endfor %}
        </tbody>
      </table>
      </div>
    </section>

    <section class="card log-card">
      <div class="log-header">
        <h2>Execution Logs</h2>
        <div class="log-actions">
          <select id="log_run_selector">
            {% for r in latest_runs %}
              <option value="{{ r.id }}" {% if loop.first %}selected{% endif %}>{{ r.run_label }}</option>
            {% endfor %}
          </select>
          <label class="checkbox">
            <input type="checkbox" id="execution_log_auto" />
            Auto refresh
          </label>
          <button type="button" id="refresh_log">Refresh</button>
          <button type="button" id="clear_log">Clear</button>
          <button type="button" id="copy_log">Copy all</button>
          <button type="button" id="copy_selection">Copy selection</button>
          <button type="button" id="toggle_execution_log_panel" class="panel-toggle" aria-label="Collapse execution log panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <pre id="log_output" class="log-output">No logs yet.</pre>
    </section>

    <section class="card log-card">
      <div class="log-header">
        <h2>System Logs</h2>
        <div class="log-actions">
          <select id="system_log_source">
            <option value="app" selected>Application</option>
            <option value="api">API</option>
          </select>
          <label class="checkbox">
            <input type="checkbox" id="system_log_auto" />
            Auto refresh
          </label>
          <button type="button" id="refresh_system_log">Refresh</button>
          <button type="button" id="clear_system_log">Clear</button>
          <button type="button" id="copy_system_log">Copy all</button>
          <button type="button" id="copy_system_selection">Copy selection</button>
          <button type="button" id="delete_system_log" class="btn btn-danger">Delete</button>
          <button type="button" id="toggle_system_log_panel" class="panel-toggle" aria-label="Collapse system log panel" title="Collapse/Expand">▾</button>
        </div>
      </div>
      <pre id="system_log_output" class="log-output">No logs yet.</pre>
    </section>
  </main>
  <script>
    const moduleSelect = document.querySelector('select[name="module"]');
    const singleInputRow = document.getElementById("single-input-row");
    const prepostInputRows = document.getElementById("prepost-input-rows");

    const uploadInputs = {
      input_zip: document.getElementById("input_zip"),
      input_pre_zip: document.getElementById("input_pre_zip"),
      input_post_zip: document.getElementById("input_post_zip")
    };
    const loadConfigButton = document.getElementById("load_config_button");
    const exportConfigButton = document.getElementById("export_config_button");
    const changePasswordButton = document.getElementById("change_password_button");
    const refreshLogButton = document.getElementById("refresh_log");
    const clearLogButton = document.getElementById("clear_log");
    const copyLogButton = document.getElementById("copy_log");
    const copySelectionButton = document.getElementById("copy_selection");
    const toggleExecutionLogPanelButton = document.getElementById("toggle_execution_log_panel");
    const executionLogAuto = document.getElementById("execution_log_auto");
    const logOutput = document.getElementById("log_output");
    const logRunSelector = document.getElementById("log_run_selector");
    const configPicker = document.getElementById("config_picker");
    const selectAllRunsButton = document.getElementById("select_all_runs");
    const unselectAllRunsButton = document.getElementById("unselect_all_runs");
    const selectOlderRunsButton = document.getElementById("select_older_runs");
    const selectErrorRunsButton = document.getElementById("select_error_runs");
    const stopSelectedRunsButton = document.getElementById("stop_selected_runs");
    const deleteSelectedRunsButton = document.getElementById("delete_selected_runs");
    const runStatusLabel = document.getElementById("run_status");
    const runModuleButton = document.getElementById("run_module_button");
    const moduleUnavailableMessage = document.getElementById("module_unavailable_message");
    const systemLogOutput = document.getElementById("system_log_output");
    const systemLogSource = document.getElementById("system_log_source");
    const systemLogAuto = document.getElementById("system_log_auto");
    const refreshSystemLogButton = document.getElementById("refresh_system_log");
    const clearSystemLogButton = document.getElementById("clear_system_log");
    const copySystemLogButton = document.getElementById("copy_system_log");
    const copySystemSelectionButton = document.getElementById("copy_system_selection");
    const deleteSystemLogButton = document.getElementById("delete_system_log");
    const toggleSystemLogPanelButton = document.getElementById("toggle_system_log_panel");
    const selectAllInputsButton = document.getElementById("select_all_inputs");
    const unselectAllInputsButton = document.getElementById("unselect_all_inputs");
    const selectOlderInputsButton = document.getElementById("select_older_inputs");
    const sendSelectedInputsButton = document.getElementById("send_selected_inputs");
    const deleteSelectedInputsButton = document.getElementById("delete_selected_inputs");
    const olderInputDatePicker = document.getElementById("older_input_date_picker");
    const toggleInputsPanelButton = document.getElementById("toggle_inputs_panel");
    const inputsPanelTable = document.getElementById("inputs_panel_table");
    let runsRefreshInFlight = false;
    const inputsTotalSizeLabel = document.getElementById("inputs_total_size");

    const inputFields = {
      input: document.getElementById("input_path"),
      input_pre: document.getElementById("input_pre_path"),
      input_post: document.getElementById("input_post_path"),
      n77_ssb_pre: document.querySelector('input[name="n77_ssb_pre"]'),
      n77_ssb_post: document.querySelector('input[name="n77_ssb_post"]'),
      n77b_ssb: document.querySelector('input[name="n77b_ssb"]'),
      allowed_n77_ssb_pre: document.querySelector('input[name="allowed_n77_ssb_pre"]'),
      allowed_n77_arfcn_pre: document.querySelector('input[name="allowed_n77_arfcn_pre"]'),
      allowed_n77_ssb_post: document.querySelector('input[name="allowed_n77_ssb_post"]'),
      allowed_n77_arfcn_post: document.querySelector('input[name="allowed_n77_arfcn_post"]'),
      ca_freq_filters: document.querySelector('input[name="ca_freq_filters"]'),
      cc_freq_filters: document.querySelector('input[name="cc_freq_filters"]'),
      profiles_audit: document.querySelector('input[name="profiles_audit"]'),
      frequency_audit: document.querySelector('input[name="frequency_audit"]'),
      export_correction_cmd: document.querySelector('input[name="export_correction_cmd"]'),
      fast_excel_export: document.querySelector('input[name="fast_excel_export"]')
    };
    const freqList = document.getElementById("freq_list");
    const networkFrequenciesField = document.getElementById("network_frequencies");
    const caFiltersInput = document.getElementById("ca_freq_filters");
    const ccFiltersInput = document.getElementById("cc_freq_filters");
    const freqTargetSelect = document.getElementById("freq_target");
    const freqAddButton = document.getElementById("freq_add");
    const freqRemoveButton = document.getElementById("freq_remove");
    const freqClearButton = document.getElementById("freq_clear");
    const selectAllButton = document.getElementById("freq_select_all");
    const blockedModuleValue = "consistency-check-bulk";
    const toggleRunsPanelButton = document.getElementById("toggle_runs_panel");
    const runsPanelTable = document.getElementById("runs_panel_table");
    const selectedInputsSingleField = document.getElementById("selected_inputs_single");
    const selectedInputsPreField = document.getElementById("selected_inputs_pre");
    const selectedInputsPostField = document.getElementById("selected_inputs_post");

    function toggleInputRows() {
      const isConsistencyCheck = moduleSelect.value === "consistency-check";
      singleInputRow.classList.toggle("hidden", isConsistencyCheck);
      prepostInputRows.classList.toggle("hidden", !isConsistencyCheck);
      selectedInputsSingleField.value = "";
      selectedInputsPreField.value = "";
      selectedInputsPostField.value = "";
    }

    function buildRepositoryPath(inputName) {
      return `/workspace/SSB_RetuningAutomations/data/inputs/${inputName}`;
    }

    function parseCsvList(raw) {
      return (raw || "").split(",").map((item) => item.trim()).filter((item) => item);
    }

    function inferParentFolderName(files) {
      if (!files || !files.length) {
        return "uploaded_input";
      }
      const first = files[0];
      const relativePath = first.webkitRelativePath || "";
      if (relativePath.includes("/")) {
        return relativePath.split("/")[0] || "uploaded_input";
      }
      const firstName = first.name || "uploaded_input";
      const dot = firstName.lastIndexOf(".");
      return (dot > 0 ? firstName.slice(0, dot) : firstName) || "uploaded_input";
    }

    function buildBatchListHtml(items) {
      const listItems = items.map((item) => `<li>${escapeHtml(item)}</li>`).join("");
      return `<div class="modal-list-wrapper"><strong>Queued folders:</strong><ul class="modal-list">${listItems}</ul></div>`;
    }



    function parseSortableValue(rawValue, sortType) {
      const value = (rawValue || "").trim();
      if (sortType === "size") {
        const n = Number.parseFloat(value.replace(/[^0-9.]/g, ""));
        return Number.isNaN(n) ? -1 : n;
      }
      if (sortType === "duration") {
        const parts = value.split(":").map((item) => Number.parseInt(item, 10));
        if (parts.length === 3 && parts.every((item) => !Number.isNaN(item))) {
          return (parts[0] * 3600) + (parts[1] * 60) + parts[2];
        }
        return -1;
      }
      if (sortType === "datetime") {
        const normalized = value.replace(/^(\d{4})-(\d{2})-(\d{2})-(\d{2}:\d{2}:\d{2})$/, "$1-$2-$3T$4");
        const ts = Date.parse(normalized);
        return Number.isNaN(ts) ? -1 : ts;
      }
      return value.toLowerCase();
    }

    function sortTableByHeader(table, header, forcedDirection = null) {
      const tbody = table?.querySelector("tbody");
      if (!tbody || !header) {
        return;
      }
      const rows = Array.from(tbody.querySelectorAll("tr"));
      if (rows.length <= 1) {
        return;
      }
      const headers = Array.from(table.querySelectorAll("thead th.sortable"));
      const columnIndex = Array.from(header.parentElement.children).indexOf(header);
      headers.forEach((other) => {
        if (!other.dataset.label) {
          other.dataset.label = other.textContent.replace(/\s*[▲▼]$/, "").trim();
        }
      });

      headers.forEach((other) => {
        if (other !== header) {
          other.dataset.sortDirection = "none";
          other.textContent = other.dataset.label || other.textContent.replace(/\s*[▲▼]$/, "").trim();
        }
      });

      const currentDirection = forcedDirection || (header.dataset.sortDirection === "asc" ? "desc" : "asc");
      header.dataset.sortDirection = currentDirection;
      const sortType = header.dataset.sortKey || "text";
      const baseLabel = header.dataset.label || header.textContent.replace(/\s*[▲▼]$/, "").trim();
      header.textContent = `${baseLabel} ${currentDirection === "asc" ? "▲" : "▼"}`;

      rows.sort((rowA, rowB) => {
        const aCell = rowA.cells[columnIndex];
        const bCell = rowB.cells[columnIndex];
        const aText = aCell ? aCell.textContent : "";
        const bText = bCell ? bCell.textContent : "";
        const aValue = parseSortableValue(aText, sortType);
        const bValue = parseSortableValue(bText, sortType);
        if (aValue < bValue) return currentDirection === "asc" ? -1 : 1;
        if (aValue > bValue) return currentDirection === "asc" ? 1 : -1;
        return 0;
      });

      rows.forEach((row) => tbody.appendChild(row));
    }

    function applyCurrentOrDefaultSort(tableSelector) {
      const table = document.querySelector(tableSelector);
      if (!table) {
        return;
      }
      const headers = Array.from(table.querySelectorAll("thead th.sortable"));
      const activeHeader = headers.find((header) => ["asc", "desc"].includes(header.dataset.sortDirection));
      if (activeHeader) {
        sortTableByHeader(table, activeHeader, activeHeader.dataset.sortDirection);
        return;
      }
      const defaultHeader = headers.find((header) => header.dataset.defaultSort);
      if (defaultHeader) {
        sortTableByHeader(table, defaultHeader, defaultHeader.dataset.defaultSort);
      }
    }

    function initSortableTable(tableSelector) {
      const table = document.querySelector(tableSelector);
      if (!table) {
        return;
      }
      const headers = Array.from(table.querySelectorAll("thead th.sortable"));
      headers.forEach((header) => {
        header.dataset.sortDirection = "none";
        header.dataset.label = header.textContent.replace(/\s*[▲▼]$/, "").trim();
        header.title = "Sort";
        header.addEventListener("click", () => sortTableByHeader(table, header));
      });
      applyCurrentOrDefaultSort(tableSelector);
    }

    function refreshInputsRepository() {
      return fetch("/inputs/list")
        .then((res) => res.json())
        .then(async (data) => {
          if (!data.ok) {
            return;
          }
          if (inputsTotalSizeLabel && data.total_size) {
            inputsTotalSizeLabel.textContent = `Total size: ${data.total_size}`;
          }
          const tbody = document.querySelector("#inputs_panel_table tbody");
          if (!tbody) {
            return;
          }
          if (!data.items || data.items.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6">No inputs in repository.</td></tr>';
            applyCurrentOrDefaultSort("#inputs_panel_table table");
            return;
          }
          tbody.innerHTML = data.items.map((item) => `
            <tr>
              <td><input type="checkbox" class="input-checkbox" value="${item.id}" data-uploaded-at="${item.uploaded_at}" /></td>
              <td>${escapeHtml(item.input_name)}</td>
              <td>${escapeHtml(item.uploaded_by)}</td>
              <td>${escapeHtml(item.uploaded_at)}</td>
              <td>${escapeHtml(item.size_mb)}</td>
              <td data-input-path="${escapeHtml(item.input_path || "")}"><select class="send-target"><option value="single">Single Input</option><option value="pre">Input PRE</option><option value="post">Input POST</option></select></td>
            </tr>
          `).join("");
          applyCurrentOrDefaultSort("#inputs_panel_table table");
        })
        .catch(() => {});
    }

    function collectSelectedInputsByTarget() {
      const selected = { single: [], pre: [], post: [] };
      Array.from(document.querySelectorAll(".input-checkbox:checked")).forEach((box) => {
        const row = box.closest("tr");
        const rowTarget = row?.querySelector(".send-target")?.value || "single";
        const inputName = row?.cells?.[1]?.textContent?.trim() || "";
        const inputPath = row?.cells?.[5]?.dataset?.inputPath || "";
        const value = inputPath || buildRepositoryPath(inputName);
        if (value && selected[rowTarget]) {
          selected[rowTarget].push(value);
        }
      });
      return selected;
    }

    function isModuleBlocked() {
      return moduleSelect.value === blockedModuleValue;
    }

    function updateModuleAvailability() {
      if (!runModuleButton || !moduleUnavailableMessage) {
        return;
      }
      const blocked = isModuleBlocked();
      runModuleButton.disabled = blocked;
      moduleUnavailableMessage.classList.toggle("hidden", !blocked);
    }


    function showModal({ title = "Notice", message = "", messageHtml = "", confirmText = "Accept", cancelText = "", showInput = false, inputValue = "", inputPlaceholder = "", tone = "info" }) {
      return new Promise((resolve) => {
        const backdrop = document.createElement("div");
        backdrop.className = "modal-backdrop";
        const box = document.createElement("div");
        box.className = "modal-box";
        const titleEl = document.createElement("h3");
        titleEl.className = "modal-title";
        titleEl.textContent = title;
        const messageEl = document.createElement("p");
        messageEl.className = "modal-message";
        if (tone === "error") {
          messageEl.classList.add("modal-message-error");
        }
        if (messageHtml) {
          messageEl.innerHTML = messageHtml;
        } else {
          messageEl.textContent = message;
        }
        box.appendChild(titleEl);
        box.appendChild(messageEl);

        let inputEl = null;
        if (showInput) {
          inputEl = document.createElement("input");
          inputEl.type = "text";
          inputEl.className = "modal-input";
          inputEl.value = inputValue;
          inputEl.placeholder = inputPlaceholder;
          box.appendChild(inputEl);
        }

        const actions = document.createElement("div");
        actions.className = "modal-actions";
        if (cancelText) {
          const cancelBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.className = "btn btn-danger";
          cancelBtn.textContent = cancelText;
          cancelBtn.addEventListener("click", () => {
            backdrop.remove();
            resolve({ ok: false, value: null });
          });
          actions.appendChild(cancelBtn);
        }
        const okBtn = document.createElement("button");
        okBtn.type = "button";
        okBtn.className = "btn btn-primary";
        okBtn.textContent = confirmText;
        okBtn.addEventListener("click", () => {
          const value = inputEl ? inputEl.value : null;
          backdrop.remove();
          resolve({ ok: true, value });
        });
        actions.appendChild(okBtn);

        box.appendChild(actions);
        backdrop.appendChild(box);
        document.body.appendChild(backdrop);
        if (inputEl) {
          inputEl.focus();
          inputEl.select();
        }
      });
    }

    function uploadZip(files, moduleValue, kindValue, inputName, overwrite, parentFolderName = "") {
      const formData = new FormData();
      Array.from(files).forEach((file) => {
        const uploadName = file.webkitRelativePath || file.name;
        formData.append("files", file, uploadName);
      });
      formData.append("module", moduleValue);
      formData.append("kind", kindValue);
      formData.append("session_id", uploadSessionId);
      formData.append("input_name", inputName || "");
      formData.append("parent_folder_name", parentFolderName || "");
      formData.append("overwrite", overwrite ? "1" : "0");
      return fetch("/uploads/zip", {
        method: "POST",
        body: formData
      }).then((res) => res.json());
    }

    document.querySelectorAll(".upload-button").forEach((button) => {
      button.addEventListener("click", () => {
        const fileInput = uploadInputs[button.dataset.file];
        if (fileInput) {
          fileInput.click();
        }
      });
    });

    Object.entries(uploadInputs).forEach(([inputId, inputElement]) => {
      inputElement.addEventListener("change", async () => {
        const files = inputElement.files;
        if (!files || files.length === 0) {
          return;
        }
        const button = document.querySelector(`[data-file="${inputId}"]`);
        const targetInput = button ? document.getElementById(button.dataset.target) : null;
        const kindValue = button ? button.dataset.kind : "";
        if (!targetInput || !kindValue) {
          return;
        }
        const inferredParentFolderName = inferParentFolderName(Array.from(files));
        const defaultInputName = inferredParentFolderName || "uploaded_input";
        const modalInput = await showModal({
          title: "Input name",
          message: "Input name for repository",
          confirmText: "Accept",
          cancelText: "Cancel",
          showInput: true,
          inputValue: defaultInputName
        });
        let selectedInputName = modalInput.value;
        if (!modalInput.ok || selectedInputName === null) {
          inputElement.value = "";
          return;
        }
        selectedInputName = selectedInputName.trim();
        if (!selectedInputName) {
          selectedInputName = defaultInputName;
        }
        targetInput.value = "Uploading...";
        uploadZip(files, moduleSelect.value, kindValue, selectedInputName, false, inferredParentFolderName)
          .then(async (data) => {
            if (data.ok && data.path) {
              targetInput.value = data.path;
              scheduleAutoSave();
              refreshInputsRepository();
              return;
            }
            if (data.error === "already_exists") {
              const overwriteResponse = await showModal({ title: "Input already exists", message: `Input ${data.existing_name} already exists. Overwrite?`, confirmText: "Accept", cancelText: "Cancel" });
              if (overwriteResponse.ok) {
                uploadZip(files, moduleSelect.value, kindValue, selectedInputName, true, inferredParentFolderName).then((retry) => {
                  if (retry.ok && retry.path) {
                    targetInput.value = retry.path;
                    scheduleAutoSave();
                    refreshInputsRepository();
                  }
                });
              } else {
                targetInput.value = "";
              }
              return;
            }
            targetInput.value = "";
          })
          .catch(() => {
            targetInput.value = "";
          })
          .finally(() => {
            inputElement.value = "";
          });
      });
    });

    function toBool(value) {
      if (!value) {
        return false;
      }
      return ["true", "1", "yes", "on"].includes(value.toLowerCase());
    }

    function normalizeConfig(config) {
      const source = config.general || config || {};
      const keyMap = {
        last_input_dir: "last_input",
        last_input_dir_audit: "last_input_audit",
        last_input_dir_cc_pre: "last_input_cc_pre",
        last_input_dir_cc_post: "last_input_cc_post",
        last_input_dir_cc_bulk: "last_input_cc_bulk",
        last_input_dir_final_cleanup: "last_input_final_cleanup",
        allowed_n77_ssb_pre_csv: "allowed_n77_ssb_pre",
        allowed_n77_arfcn_pre_csv: "allowed_n77_arfcn_pre",
        allowed_n77_ssb_post_csv: "allowed_n77_ssb_post",
        allowed_n77_arfcn_post_csv: "allowed_n77_arfcn_post"
      };
      const normalized = { ...source };
      Object.entries(keyMap).forEach(([rawKey, logicalKey]) => {
        if (rawKey in source && !(logicalKey in normalized)) {
          normalized[logicalKey] = source[rawKey];
        }
      });
      return normalized;
    }

    function applyConfigValues(config) {
      const general = normalizeConfig(config);
      const moduleValue = moduleSelect.value;
      const inputMappings = {
        "configuration-audit": general.last_input_audit || general.last_input || "",
        "consistency-check-bulk": general.last_input_cc_bulk || general.last_input || "",
        "final-cleanup": general.last_input_final_cleanup || general.last_input || ""
      };

      if (moduleValue === "consistency-check") {
        inputFields.input_pre.value = general.last_input_cc_pre || "";
        inputFields.input_post.value = general.last_input_cc_post || "";
      } else {
        inputFields.input.value = inputMappings[moduleValue] || "";
      }

      inputFields.n77_ssb_pre.value = general.n77_ssb_pre || inputFields.n77_ssb_pre.value;
      inputFields.n77_ssb_post.value = general.n77_ssb_post || inputFields.n77_ssb_post.value;
      inputFields.n77b_ssb.value = general.n77b_ssb || inputFields.n77b_ssb.value;
      inputFields.allowed_n77_ssb_pre.value = general.allowed_n77_ssb_pre || inputFields.allowed_n77_ssb_pre.value;
      inputFields.allowed_n77_arfcn_pre.value = general.allowed_n77_arfcn_pre || inputFields.allowed_n77_arfcn_pre.value;
      inputFields.allowed_n77_ssb_post.value = general.allowed_n77_ssb_post || inputFields.allowed_n77_ssb_post.value;
      inputFields.allowed_n77_arfcn_post.value = general.allowed_n77_arfcn_post || inputFields.allowed_n77_arfcn_post.value;
      inputFields.ca_freq_filters.value = general.ca_freq_filters || inputFields.ca_freq_filters.value;
      inputFields.cc_freq_filters.value = general.cc_freq_filters || inputFields.cc_freq_filters.value;
      inputFields.profiles_audit.checked = toBool(general.profiles_audit);
      inputFields.frequency_audit.checked = toBool(general.frequency_audit);
      inputFields.export_correction_cmd.checked = toBool(general.export_correction_cmd);
      inputFields.fast_excel_export.checked = toBool(general.fast_excel_export);
      if (general.network_frequencies) {
        updateNetworkFrequencies(parseCsv(general.network_frequencies));
      }
    }

    function escapeHtml(text) {
      return text.replace(/[&<>"']/g, (char) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }[char]));
    }

    function parseIni(content) {
      const result = {};
      let currentSection = "";
      content.split(/\r?\n/).forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith(";") || trimmed.startsWith("#")) {
          return;
        }
        const sectionMatch = trimmed.match(/^\[(.+)\]$/);
        if (sectionMatch) {
          currentSection = sectionMatch[1].trim();
          return;
        }
        const equalsIndex = trimmed.indexOf("=");
        if (equalsIndex === -1) {
          return;
        }
        const key = trimmed.slice(0, equalsIndex).trim();
        const value = trimmed.slice(equalsIndex + 1).trim();
        if (!result[currentSection]) {
          result[currentSection] = {};
        }
        result[currentSection][key] = value;
      });
      return result;
    }

    function parseCsv(value) {
      return value
        .split(",")
        .map((item) => item.trim())
        .filter((item) => item);
    }

    function formatCsv(values) {
      const unique = Array.from(new Set(values));
      unique.sort((a, b) => {
        const aNum = Number(a);
        const bNum = Number(b);
        if (!Number.isNaN(aNum) && !Number.isNaN(bNum)) {
          return aNum - bNum;
        }
        return a.localeCompare(b);
      });
      return unique.join(",");
    }

    function getSelectedFrequencies() {
      return Array.from(freqList.selectedOptions).map((option) => option.value);
    }

    function updateNetworkFrequencies(values) {
      if (!values || values.length === 0) {
        return;
      }
      freqList.innerHTML = "";
      values.forEach((value) => {
        const option = document.createElement("option");
        option.value = value;
        option.textContent = value;
        freqList.appendChild(option);
      });
      networkFrequenciesField.value = formatCsv(values);
    }

    function addToFilters(targetInput) {
      const selected = getSelectedFrequencies();
      if (selected.length === 0) {
        return;
      }
      const current = parseCsv(targetInput.value);
      targetInput.value = formatCsv([...current, ...selected]);
      scheduleAutoSave();
    }

    function removeFromFilters(targetInput) {
      const selected = new Set(getSelectedFrequencies());
      if (selected.size === 0) {
        return;
      }
      const current = parseCsv(targetInput.value).filter((value) => !selected.has(value));
      targetInput.value = current.join(",");
      scheduleAutoSave();
    }

    function clearFilters(targetInput) {
      targetInput.value = "";
      scheduleAutoSave();
    }

    function selectAllFrequencies() {
      Array.from(freqList.options).forEach((option) => {
        option.selected = true;
      });
    }

    function renderLog(text) {
      if (!text) {
        logOutput.textContent = "No logs yet.";
        return;
      }
      const lines = text.split(/\r?\n/);
      logOutput.innerHTML = lines.map((line) => {
        let cls = "log-info";
        if (line.includes("[ERROR]")) {
          cls = "log-error";
        } else if (line.includes("[WARNING]")) {
          cls = "log-warning";
        } else if (line.includes("[DEBUG]")) {
          cls = "log-debug";
        }
        return `<span class="${cls}">${escapeHtml(line)}</span>`;
      }).join("\n");
      if (executionLogAuto?.checked) {
        logOutput.scrollTop = logOutput.scrollHeight;
      }
    }

    function buildNoCacheUrl(baseUrl) {
      const separator = baseUrl.includes("?") ? "&" : "?";
      return `${baseUrl}${separator}_=${Date.now()}_${Math.random().toString(36).slice(2)}`;
    }

    function fetchLatestLog() {
      fetch(buildNoCacheUrl("/logs/latest"), { cache: "no-store" })
        .then((res) => res.json())
        .then((data) => {
          renderLog(data.log || "");
        })
        .catch(() => {
          renderLog("");
        });
    }

    function pickExecutionLogRunId(items, currentRunId) {
      const runningItems = items
        .filter((item) => item.status_lower === "running" || item.status_lower === "canceling")
        .slice()
        .sort((a, b) => {
          const aStart = String(a.started_at_raw || a.started_at || "");
          const bStart = String(b.started_at_raw || b.started_at || "");
          if (aStart !== bStart) {
            return aStart.localeCompare(bStart);
          }
          return Number(a.id) - Number(b.id);
        });
      if (runningItems.length > 0) {
        return String(runningItems[0].id);
      }

      const queuedItems = items
        .filter((item) => item.status_lower === "queued")
        .slice()
        .sort((a, b) => Number(a.id) - Number(b.id));
      if (queuedItems.length > 0) {
        return String(queuedItems[0].id);
      }

      const currentExists = items.some((item) => String(item.id) === String(currentRunId || ""));
      if (currentExists) {
        return String(currentRunId);
      }

      return items[0] ? String(items[0].id) : "";
    }

    function refreshRunsTable() {
      if (runsRefreshInFlight) {
        return Promise.resolve();
      }
      runsRefreshInFlight = true;
      return fetch(buildNoCacheUrl("/runs/list"), { cache: "no-store" })
        .then((res) => res.json())
        .then((data) => {
          if (!data.ok) {
            return;
          }
          const tbody = document.querySelector("#runs_panel_table tbody");
          if (!tbody) {
            return;
          }
          const selectedIds = new Set(Array.from(document.querySelectorAll(".run-checkbox:checked")).map((box) => Number(box.value)));
          if (!data.items || data.items.length === 0) {
            tbody.innerHTML = '<tr><td colspan="12">No executions yet.</td></tr>';
            applyCurrentOrDefaultSort("#runs_panel_table table");
            return;
          }

          tbody.innerHTML = data.items.map((item) => {
            const rowClass = item.status_lower === "error" ? "run-row run-error" : (item.status_lower === "success" ? "run-row run-success" : (item.status_lower === "canceled" ? "run-row run-canceled" : "run-row"));
            const checked = selectedIds.has(item.id) ? 'checked' : '';
            const outputCell = item.output_zip ? `<a href="/runs/${item.id}/download">Download zip</a>` : "—";
            const logCell = item.output_log_file ? `<a href="/runs/${item.id}/log">Download log</a>` : "—";
            return `
            <tr class="${rowClass}" data-run-id="${item.id}" data-status="${item.status_lower}">
              <td><input type="checkbox" class="run-checkbox" value="${item.id}" data-start="${item.started_at}" data-status="${item.status_lower}" ${checked} /></td>
              <td>${escapeHtml(item.id)}</td>
              <td>${escapeHtml(item.module)}</td>
              <td>${escapeHtml(item.tool_version || "—")}</td>
              <td>${escapeHtml(item.input_name || "—")}</td>
              <td class="run-status-cell">${escapeHtml(item.status_display)}</td>
              <td class="run-start-cell">${escapeHtml(item.started_at || "")}</td>
              <td class="run-finished-cell">${escapeHtml(item.finished_at || "")}</td>
              <td class="run-duration-cell">${escapeHtml(item.duration_hms || "00:00:00")}</td>
              <td class="run-output-cell">${outputCell}</td>
              <td class="run-log-cell">${logCell}</td>
              <td>${escapeHtml(item.size_mb || "0.00 MB")}</td>
            </tr>`;
          }).join("");

          if (logRunSelector) {
            const currentRunId = logRunSelector.value;
            const nextRunId = pickExecutionLogRunId(data.items, currentRunId);
            logRunSelector.innerHTML = data.items.map((item) => `<option value="${item.id}">${escapeHtml(item.run_label)}</option>`).join("");
            if (nextRunId) {
              logRunSelector.value = nextRunId;
            }
            fetchLogByRun();
          }

          const hasRunning = data.items.some((item) => item.status_lower === "running" || item.status_lower === "canceling");
          const hasQueued = data.items.some((item) => item.status_lower === "queued");
          const hasError = data.items.some((item) => item.status_lower === "error");
          const latestStatus = hasRunning ? "running" : (hasQueued ? "queued" : ((data.items[0]?.status_lower || "").toLowerCase()));
          runStatusLabel.dataset.latestStatus = latestStatus;
          if (latestStatus === "ok" || latestStatus === "success") {
            runStatusLabel.textContent = "SUCCESS!!!";
            runStatusLabel.className = "run-status status-done";
          } else if (latestStatus === "error" || (!latestStatus && hasError)) {
            runStatusLabel.textContent = "ERROR!!!";
            runStatusLabel.className = "run-status status-error";
          } else if (latestStatus === "running" || latestStatus === "queued") {
            runStatusLabel.textContent = "Task queued...";
            runStatusLabel.className = "run-status status-running";
          }

          applyCurrentOrDefaultSort("#runs_panel_table table");
        })
        .catch(() => {})
        .finally(() => {
          runsRefreshInFlight = false;
        });
    }

    function fetchLogByRun() {
      const runId = logRunSelector?.value;
      if (!runId) {
        fetchLatestLog();
        return;
      }
      fetch(buildNoCacheUrl(`/logs/by_run/${runId}`), { cache: "no-store" })
        .then((res) => res.json())
        .then((data) => {
          renderLog(data.log || "");
        })
        .catch(() => {
          renderLog("");
        });
    }

    function renderSystemLog(text) {
      if (!text) {
        systemLogOutput.textContent = "No logs yet.";
        if (systemLogAuto?.checked) {
          systemLogOutput.scrollTop = systemLogOutput.scrollHeight;
        }
        return;
      }
      const lines = text.split(/\r?\n/);
      systemLogOutput.innerHTML = lines.map((line) => {
        let cls = "log-info";
        if (line.includes("[ERROR]")) {
          cls = "log-error";
        } else if (line.includes("[WARNING]")) {
          cls = "log-warning";
        } else if (line.includes("[DEBUG]")) {
          cls = "log-debug";
        }
        return `<span class="${cls}">${escapeHtml(line)}</span>`;
      }).join("\n");
      if (systemLogAuto?.checked) {
        systemLogOutput.scrollTop = systemLogOutput.scrollHeight;
      }
    }

    function fetchSystemLog() {
      const source = systemLogSource?.value || "app";
      fetch(buildNoCacheUrl(`/logs/system?source=${encodeURIComponent(source)}`), { cache: "no-store" })
        .then((res) => res.json())
        .then((data) => {
          renderSystemLog(data.log || "");
        })
        .catch(() => {
          renderSystemLog("");
        });
    }

    function collectFormValues() {
      const form = document.querySelector(".module-form");
      const data = new FormData(form);
      const payload = {};
      data.forEach((value, key) => {
        payload[key] = value;
      });
      ["profiles_audit", "frequency_audit", "export_correction_cmd", "fast_excel_export"].forEach((key) => {
        payload[key] = form.querySelector(`input[name="${key}"]`).checked;
      });
      return payload;
    }

    let saveTimeout = null;
    function scheduleAutoSave() {
      if (saveTimeout) {
        clearTimeout(saveTimeout);
      }
      saveTimeout = setTimeout(() => {
        fetch("/settings/update", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(collectFormValues())
        }).catch(() => {});
      }, 400);
    }

    document.querySelectorAll(".module-form input, .module-form select").forEach((field) => {
      field.addEventListener("change", scheduleAutoSave);
      field.addEventListener("input", scheduleAutoSave);
    });

    loadConfigButton.addEventListener("click", () => {
      configPicker.click();
    });

    configPicker.addEventListener("change", () => {
      const file = configPicker.files[0];
      if (!file) {
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        const parsed = parseIni(reader.result || "");
        applyConfigValues(parsed);
        scheduleAutoSave();
      };
      reader.readAsText(file);
    });

    exportConfigButton.addEventListener("click", () => {
      window.location.href = "/config/export";
    });

    changePasswordButton.addEventListener("click", async () => {
      const response = await showModal({
        title: "Change password",
        message: "Enter a new password:",
        confirmText: "Accept",
        cancelText: "Cancel",
        showInput: true,
        inputPlaceholder: "New password"
      });
      const newPassword = (response.value || "").trim();
      if (!response.ok || !newPassword) {
        return;
      }
      fetch("/account/change_password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ new_password: newPassword })
      }).then(async (res) => {
        if (res.ok) {
          await showModal({ title: "Password updated", message: "Password updated. Please sign in again.", confirmText: "Accept" });
          window.location.href = "/login";
        }
      });
    });

    refreshLogButton.addEventListener("click", fetchLogByRun);
    clearLogButton.addEventListener("click", () => {
      logOutput.textContent = "";
    });

    function copyToClipboard(text) {
      if (!text) {
        return;
      }
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).catch(() => {});
        return;
      }
      const helper = document.createElement("textarea");
      helper.value = text;
      document.body.appendChild(helper);
      helper.select();
      document.execCommand("copy");
      document.body.removeChild(helper);
    }

    copyLogButton.addEventListener("click", () => {
      copyToClipboard(logOutput.textContent || "");
    });

    copySelectionButton.addEventListener("click", () => {
      const selection = window.getSelection();
      if (selection) {
        copyToClipboard(selection.toString());
      }
    });

    if (refreshSystemLogButton) {
      refreshSystemLogButton.addEventListener("click", fetchSystemLog);
    }
    if (clearSystemLogButton) {
      clearSystemLogButton.addEventListener("click", () => {
        systemLogOutput.textContent = "";
      });
    }
    if (deleteSystemLogButton) {
      deleteSystemLogButton.addEventListener("click", async () => {
        const ok = await showModal({ title: "Delete system log", message: "Delete all contents from the selected system log file?", confirmText: "Accept", cancelText: "Cancel" });
        if (!ok.ok) {
          return;
        }
        const source = systemLogSource?.value || "app";
        fetch(`/logs/system/delete?source=${encodeURIComponent(source)}`, { method: "POST" })
          .then((res) => res.json())
          .then((data) => {
            if (data.ok) {
              renderSystemLog("");
            }
          })
          .catch(() => {});
      });
    }
    if (copySystemLogButton) {
      copySystemLogButton.addEventListener("click", () => {
        copyToClipboard(systemLogOutput.textContent || "");
      });
    }
    if (copySystemSelectionButton) {
      copySystemSelectionButton.addEventListener("click", () => {
        const selection = window.getSelection();
        if (selection) {
          copyToClipboard(selection.toString());
        }
      });
    }
    if (systemLogSource) {
      systemLogSource.addEventListener("change", fetchSystemLog);
    }

    function getTargetFiltersInput() {
      return freqTargetSelect.value === "cc" ? ccFiltersInput : caFiltersInput;
    }

    freqAddButton.addEventListener("click", () => addToFilters(getTargetFiltersInput()));
    freqRemoveButton.addEventListener("click", () => removeFromFilters(getTargetFiltersInput()));
    freqClearButton.addEventListener("click", () => clearFilters(getTargetFiltersInput()));
    selectAllButton.addEventListener("click", selectAllFrequencies);

    function getSelectedRunIds() {
      return Array.from(document.querySelectorAll(".run-checkbox:checked")).map((box) => Number(box.value));
    }

    selectAllRunsButton.addEventListener("click", () => {
      document.querySelectorAll(".run-checkbox").forEach((box) => {
        box.checked = true;
      });
    });

    unselectAllRunsButton.addEventListener("click", () => {
      document.querySelectorAll(".run-checkbox").forEach((box) => {
        box.checked = false;
      });
    });

    function selectErrorRuns() {
      const table = document.querySelector(".latest-runs-scroll table");
      const headerCells = table ? table.querySelectorAll("thead th") : [];
      let statusIndex = -1;
      headerCells.forEach((cell, index) => {
        if (cell.textContent.trim().toLowerCase() === "status") {
          statusIndex = index;
        }
      });

      document.querySelectorAll(".run-checkbox").forEach((box) => {
        const row = box.closest("tr");
        const statusColumn = row && statusIndex >= 0 ? row.cells[statusIndex] : null;
        const statusText = statusColumn ? statusColumn.textContent.trim().toLowerCase() : "";
        const statusAttr = (row?.dataset.status || box.dataset.status || "").trim().toLowerCase();
        if (statusText === "error" || statusAttr === "error" || row?.classList.contains("run-error")) {
          box.checked = true;
        }
      });
    }

    if (selectErrorRunsButton) {
      selectErrorRunsButton.addEventListener("click", selectErrorRuns);
    }

    let lastChecked = null;
    document.querySelectorAll(".run-checkbox").forEach((box) => {
      box.addEventListener("click", (event) => {
        if (!event.shiftKey || !lastChecked) {
          lastChecked = box;
          return;
        }
        const checkboxes = Array.from(document.querySelectorAll(".run-checkbox"));
        const start = checkboxes.indexOf(box);
        const end = checkboxes.indexOf(lastChecked);
        const [min, max] = start < end ? [start, end] : [end, start];
        for (let i = min; i <= max; i += 1) {
          checkboxes[i].checked = lastChecked.checked;
        }
      });
    });

    selectOlderRunsButton.addEventListener("click", () => {
      const picker = document.getElementById("older_date_picker");
      if (picker) {
        picker.showPicker();
      }
    });

    const olderDatePicker = document.getElementById("older_date_picker");
    olderDatePicker.addEventListener("change", () => {
      const selected = olderDatePicker.value;
      if (!selected) {
        return;
      }
      const threshold = new Date(`${selected}T00:00:00`);
      if (Number.isNaN(threshold.getTime())) {
        return;
      }
      document.querySelectorAll(".run-checkbox").forEach((box) => {
        const startValue = box.dataset.start;
        if (!startValue) {
          return;
        }
        const parts = startValue.split("-");
        const normalized = `${parts[0]}-${parts[1]}-${parts[2]}T${parts[3] || "00:00:00"}`;
        const startDate = new Date(normalized);
        if (!Number.isNaN(startDate.getTime()) && startDate < threshold) {
          box.checked = true;
        }
      });
      olderDatePicker.value = "";
    });

    stopSelectedRunsButton?.addEventListener("click", async () => {
      const ids = getSelectedRunIds();
      if (ids.length === 0) {
        return;
      }
      const stopRunsAnswer = await showModal({ title: "Stop executions", message: "Stop selected queued/running tasks?", confirmText: "Accept", cancelText: "Cancel" });
      if (!stopRunsAnswer.ok) {
        return;
      }
      ids.forEach((id) => {
        const row = document.querySelector(`#runs_panel_table tr[data-run-id="${id}"]`);
        const statusCell = row?.querySelector(".run-status-cell");
        if (statusCell) {
          statusCell.textContent = "Canceling";
        }
      });

      fetch(buildNoCacheUrl("/runs/stop"), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ids }),
        cache: "no-store"
      })
        .then(() => {
          let attempts = 0;
          const maxAttempts = 8;
          const pollStopStatus = () => {
            attempts += 1;
            return refreshRunsTable().then(() => {
              const stillCanceling = ids.some((id) => {
                const row = document.querySelector(`#runs_panel_table tr[data-run-id="${id}"]`);
                if (!row) {
                  return false;
                }
                const status = String(row.getAttribute("data-status") || "").toLowerCase();
                return status === "running" || status === "canceling";
              });
              if (!stillCanceling || attempts >= maxAttempts) {
                return;
              }
              return new Promise((resolve) => setTimeout(resolve, 1000)).then(pollStopStatus);
            });
          };
          return pollStopStatus();
        })
        .catch(() => {});
    });

    deleteSelectedRunsButton.addEventListener("click", async () => {
      const ids = getSelectedRunIds();
      if (ids.length === 0) {
        return;
      }
      const removeRunsAnswer = await showModal({ title: "Delete executions", message: "This will delete the Uploads and Exports for the selected executions. Continue?", confirmText: "Accept", cancelText: "Cancel" });
      if (!removeRunsAnswer.ok) {
        return;
      }
      fetch("/runs/delete", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ids })
      }).then(() => window.location.reload());
    });

    function buildSessionId() {
      const now = new Date();
      const pad = (value) => String(value).padStart(2, "0");
      return (
        now.getFullYear().toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        "_" +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds())
      );
    }

    let uploadSessionId = buildSessionId();

    function getSelectedInputIds() {
      return Array.from(document.querySelectorAll(".input-checkbox:checked")).map((box) => Number(box.value));
    }

    selectAllInputsButton?.addEventListener("click", () => {
      document.querySelectorAll(".input-checkbox").forEach((box) => { box.checked = true; });
    });
    unselectAllInputsButton?.addEventListener("click", () => {
      document.querySelectorAll(".input-checkbox").forEach((box) => { box.checked = false; });
    });
    selectOlderInputsButton?.addEventListener("click", () => olderInputDatePicker?.showPicker());
    olderInputDatePicker?.addEventListener("change", () => {
      const selected = olderInputDatePicker.value;
      if (!selected) return;
      const threshold = new Date(`${selected}T00:00:00`);
      document.querySelectorAll(".input-checkbox").forEach((box) => {
        const raw = box.dataset.uploadedAt || "";
        const normalized = raw.replace(/-/g,":");
        const d = new Date(normalized);
        if (!Number.isNaN(d.getTime()) && d < threshold) box.checked = true;
      });
      olderInputDatePicker.value = "";
    });

    sendSelectedInputsButton?.addEventListener("click", async () => {
      const selectedByTarget = collectSelectedInputsByTarget();
      const totalSelected = selectedByTarget.single.length + selectedByTarget.pre.length + selectedByTarget.post.length;
      if (!totalSelected) {
        await showModal({ title: "Selection required", message: "Select at least one input in Inputs Repository panel.", confirmText: "Accept" });
        return;
      }

      const isConsistencyCheck = moduleSelect.value === "consistency-check";
      if (isConsistencyCheck) {
        if (selectedByTarget.single.length > 0 || (selectedByTarget.pre.length === 0 && selectedByTarget.post.length === 0)) {
          await showModal({
            title: "❌ Invalid target selection",
            message: "Module 2 expects Input PRE and/or Input POST targets only. Please set target column values to Input PRE or Input POST and try again.",
            confirmText: "Accept",
            tone: "error"
          });
          return;
        }
      } else if (selectedByTarget.pre.length > 0 || selectedByTarget.post.length > 0) {
        await showModal({
          title: "❌ Invalid target selection",
          message: "This module expects Single Input targets only. Please set all selected target values to Single Input and try again.",
          confirmText: "Accept",
          tone: "error"
        });
        return;
      }

      if (selectedByTarget.single.length) {
        inputFields.input.value = selectedByTarget.single.join(",");
      }
      if (selectedByTarget.pre.length) {
        inputFields.input_pre.value = selectedByTarget.pre.join(",");
      }
      if (selectedByTarget.post.length) {
        inputFields.input_post.value = selectedByTarget.post.join(",");
      }
      scheduleAutoSave();
      await showModal({ title: "Inputs assigned", message: "Selected inputs were sent to Input / Input PRE / Input POST based on each row target.", confirmText: "Accept" });
    });
    deleteSelectedInputsButton?.addEventListener("click", async () => {
      const ids = getSelectedInputIds();
      if (!ids.length) return;
      const removeInputsAnswer = await showModal({ title: "Delete inputs", message: "Delete selected inputs?", confirmText: "Accept", cancelText: "Cancel" });
      if (!removeInputsAnswer.ok) return;
      fetch("/inputs/delete", {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({ids})})
        .then((res) => res.json())
         .then(async (data) => {
          if (!data.ok && data.error === "forbidden_inputs") {
            await showModal({ title: "Action not allowed", message: "Only inputs uploaded by your user can be deleted. Admin users can delete any input only from the Admin panel.", confirmText: "Accept" });
          }
          return refreshInputsRepository();
        });
    });
    toggleRunsPanelButton?.addEventListener("click", () => {
      runsPanelTable?.classList.toggle("hidden");
      if (toggleRunsPanelButton) {
        toggleRunsPanelButton.textContent = runsPanelTable?.classList.contains("hidden") ? "▸" : "▾";
      }
    });
    toggleExecutionLogPanelButton?.addEventListener("click", () => {
      logOutput?.classList.toggle("hidden");
      if (toggleExecutionLogPanelButton) {
        toggleExecutionLogPanelButton.textContent = logOutput?.classList.contains("hidden") ? "▸" : "▾";
      }
    });
    toggleSystemLogPanelButton?.addEventListener("click", () => {
      systemLogOutput?.classList.toggle("hidden");
      if (toggleSystemLogPanelButton) {
        toggleSystemLogPanelButton.textContent = systemLogOutput?.classList.contains("hidden") ? "▸" : "▾";
      }
    });
    toggleInputsPanelButton?.addEventListener("click", () => {
      inputsPanelTable?.classList.toggle("hidden");
      if (toggleInputsPanelButton) {
        toggleInputsPanelButton.textContent = inputsPanelTable?.classList.contains("hidden") ? "▸" : "▾";
      }
    });

    moduleSelect.addEventListener("change", () => {
      toggleInputRows();
      updateModuleAvailability();
    });
    toggleInputRows();
    updateModuleAvailability();
    const moduleForm = document.querySelector(".module-form");
    moduleForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      if (isModuleBlocked()) {
        updateModuleAvailability();
        return;
      }
      logOutput.textContent = "";
      uploadSessionId = buildSessionId();
      const isConsistencyCheck = moduleSelect.value === "consistency-check";
      const singleInputs = parseCsvList(inputFields.input.value);
      const preInputs = parseCsvList(inputFields.input_pre.value);
      const postInputs = parseCsvList(inputFields.input_post.value);
      selectedInputsSingleField.value = "";
      selectedInputsPreField.value = "";
      selectedInputsPostField.value = "";

      let confirmationMessage = "";
      let confirmationHtml = "";
      if (!isConsistencyCheck && singleInputs.length > 1) {
        selectedInputsSingleField.value = singleInputs.join("|");
        inputFields.input.value = singleInputs[0];
        confirmationMessage = `You selected ${singleInputs.length} inputs. Queue one task per input?`;
        confirmationHtml = `${escapeHtml(confirmationMessage)}${buildBatchListHtml(singleInputs)}`;
      } else if (isConsistencyCheck && (preInputs.length > 1 || postInputs.length > 1)) {
        const isPairable = preInputs.length === postInputs.length || preInputs.length === 1 || postInputs.length === 1;
        if (!isPairable) {
          showModal({ title: "Invalid PRE/POST pairing", message: "Cannot queue tasks: PRE and POST selections have different lengths and both are greater than 1.", confirmText: "Accept" });
          event.preventDefault();
          return;
        }
        selectedInputsPreField.value = preInputs.join("|");
        selectedInputsPostField.value = postInputs.join("|");
        inputFields.input_pre.value = preInputs[0] || "";
        inputFields.input_post.value = postInputs[0] || "";
        const queuedCount = Math.max(preInputs.length, postInputs.length);
        const pairingList = Array.from({ length: queuedCount }).map((_, idx) => {
          const preValue = preInputs.length > 1 ? preInputs[idx] : (preInputs[0] || "");
          const postValue = postInputs.length > 1 ? postInputs[idx] : (postInputs[0] || "");
          return `PRE: ${preValue} | POST: ${postValue}`;
        });
        confirmationMessage = `You selected multiple PRE/POST inputs. Queue ${queuedCount} task(s) using those pairings?`;
        confirmationHtml = `${escapeHtml(confirmationMessage)}${buildBatchListHtml(pairingList)}`;
      }

      const currentInput = isConsistencyCheck ? (document.getElementById("input_post_path")?.value || "") : (document.getElementById("input_path")?.value || "");
      const taskName = currentInput.split("/").filter(Boolean).pop() || "unknown";
      const confirmText = confirmationMessage || `Queue task: ${taskName}?`;
      const queueAnswer = await showModal({ title: "Queue task", message: confirmText, messageHtml: confirmationHtml, confirmText: "Accept", cancelText: "Cancel" });
      if (!queueAnswer.ok) {
        return;
      }
      runStatusLabel.textContent = "Task queued...";
      runStatusLabel.className = "run-status status-running";
      runModuleButton.disabled = true;
      moduleForm.submit();
    });
    if (runStatusLabel) {
      const latestStatus = (runStatusLabel.dataset.latestStatus || "").trim().toLowerCase();
      if (latestStatus === "ok") {
        runStatusLabel.textContent = "SUCCESS!!!";
        runStatusLabel.className = "run-status status-done";
      } else if (latestStatus === "error") {
        runStatusLabel.textContent = "ERROR!!!";
        runStatusLabel.className = "run-status status-error";
      }
    }
    initSortableTable("#inputs_panel_table table");
    initSortableTable("#runs_panel_table table");

    fetch("/config/load")
      .then((res) => res.json())
      .then((data) => {
        applyConfigValues(data);
      })
      .catch(() => {});
    logRunSelector?.addEventListener("change", fetchLogByRun);
    fetchLogByRun();
    fetchSystemLog();
    refreshInputsRepository();
    refreshRunsTable();

    setInterval(() => {
      refreshRunsTable();
    }, 3000);

    let executionLogTimer = null;
    if (executionLogAuto) {
      executionLogAuto.addEventListener("change", () => {
        if (executionLogAuto.checked) {
          if (executionLogTimer) {
            clearInterval(executionLogTimer);
          }
          fetchLogByRun();
          executionLogTimer = setInterval(fetchLogByRun, 3000);
        } else if (executionLogTimer) {
          clearInterval(executionLogTimer);
          executionLogTimer = null;
        }
      });
      if (executionLogAuto.checked) {
        fetchLogByRun();
        executionLogTimer = setInterval(fetchLogByRun, 3000);
      }
    }

    let systemLogTimer = null;
    if (systemLogAuto) {
      systemLogAuto.addEventListener("change", () => {
        if (systemLogAuto.checked) {
          fetchSystemLog();
          systemLogTimer = setInterval(fetchSystemLog, 3000);
        } else if (systemLogTimer) {
          clearInterval(systemLogTimer);
          systemLogTimer = null;
        }
      });
      if (systemLogAuto.checked) {
        fetchSystemLog();
        systemLogTimer = setInterval(fetchSystemLog, 3000);
      }
    }
  </script>
</body>
</html>
